---
layout: paper
part: Appendix
---
<div class="WordSection1">
 <p class="romeinscijfer" id="appendices">
  &nbsp;
 </p>
 <div class="AutoStyle00">
  <h1 class="AutoStyle01" id="h_appendices">
   Appendices
  </h1>
 </div>
 <p class="sektie1">
  Appendix A describes a number of built-in Prolog predicates, and lists a library of utility programs. These predicates are used in various programs throughout the book.
 </p>
 <p class="sektie">
  Appendix B gives two programs converting to and from clausal logic. The first program transforms a formula in first-order Predicate Logic to clausal form, as described in section 2.5. The second program completes a given set of general clauses by means of Predicate Completion (section 8.2). The output of this program is a formula in Predicate Logic, which can be transformed back to clausal form by means of the first program.
 </p>
 <p class="sektie">
  Appendix C gives detailed answers to selected exercises.
 </p>
</div>
<b>
 <span class="AutoStyle78">
  <br clear="all"/>
 </span>
</b>
<div class="WordSection2">
 <p class="cijfer" id="a_catalogue_of_useful_predicates">
  A
 </p>
 <h2 id="h_a_catalogue_of_useful_predicates">
  A catalogue of useful predicates
 </h2>
 <p class="sektie1">
  Appendix A.1 describes a number of built-in Prolog&nbsp;predicates. Appendix A.2 comprises a small library of utility predicates that are used by programs in this book.
 </p>
 <h3 id="built_in_predicates">
  A.1&nbsp;&nbsp;Built-in predicates
 </h3>
 <p class="sektie1">
  <i>Term manipulation</i>
 </p>
 <p class="opsomming AutoStyle79">
  <tt>Term1 = Term2</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Term1</tt> and <tt>Term2</tt> are unified.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>Term1 \= Term2</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Term1</tt> and <tt>Term2</tt> cannot be unified.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>Term1 == Term2</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Term1</tt> and <tt>Term2</tt> are bound to the same term.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>Term1 \== Term2</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Term1</tt> and <tt>Term2</tt> are bound to different terms.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>var(V)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>V</tt> is an unbound variable.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>arg(N,T,A)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>A</tt> is the <tt>N</tt> -th argument of term <tt>T</tt>.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>functor(T,F,N)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>T</tt> is a term with functor <tt>F</tt> and arity <tt>N</tt>.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>Term =.. List</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>List</tt> is a list starting with the functor of <tt>Term</tt>, followed by its arguments.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>varsin(Term,Vs)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Vs</tt> is a list of the variables in <tt>Term</tt>.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>numbervars(T,N,M)</tt>&nbsp;&nbsp;the variables in term <tt>T</tt> are instantiated to terms of the form <tt>'$VAR'(</tt> <i>n</i> <tt>)</tt>, where <i>n</i> is an integer which has a different value for each distinct variable. The variables will be numbered starting from <tt>N</tt>, and <tt>M</tt> is the next unused number.
 </p>
 <p class="sektie1">
  <i>Database manipulation</i>
 </p>
 <p class="opsomming AutoStyle79">
  <tt>assert(Clause)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Clause</tt> is added at the end of the database (can also be a single atom, without a body).
 </p>
 <p class="opsomming AutoStyle79">
  <tt>asserta(Clause)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Clause</tt> is added at the <i>top</i> of the database.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>clause(H,B)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>H:-B</tt> is a clause in the database (<tt>H</tt> must be instantiated).
 </p>
 <p class="opsomming AutoStyle79">
  <tt>retract(Clause)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the first clause unifying with <tt>Clause</tt> is removed from the database.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>retractall(Head)</tt>&nbsp;&nbsp;&nbsp;&nbsp;all clauses with head unifying with <tt>Head</tt> are removed from the database.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>kill(Predicate)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all clauses defining <tt>Predicate</tt> are removed from the database.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>save(File)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;save the clauses in the database to <tt>File</tt>.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>consult(File)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load the clauses in <tt>File</tt> into the database.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>op(P,Type,Name)&nbsp;&nbsp;&nbsp;</tt> declare an operator <tt>Name</tt> with priority <tt>P</tt> (a number between 0 and 1200, lower priority binds stronger); <tt>Type</tt> is <tt>fx</tt> or <tt>fy</tt> for prefix, <tt>xfx</tt>, <tt>xfy</tt> or <tt>yfx</tt> for infix, and <tt>xf</tt> or <tt>yf</tt> for postfix.
 </p>
 <p class="sektie1">
  <i>Control</i>
 </p>
 <p class="opsomming AutoStyle79">
  <tt>call(Goal)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call <tt>Goal</tt> (must be instantiated to a goal).
 </p>
 <p class="opsomming AutoStyle79">
  <tt>not(Goal)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Goal</tt> is not provable (must be instantiated to a goal).<br>
  <tt>not/1</tt>&nbsp;could be defined as<br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;not(Goal):-call(Goal),!,fail.<br>
   &nbsp;&nbsp;&nbsp;&nbsp;not(Goal).</tt>
 </p>
 <p class="opsomming AutoStyle79">
  <tt>fail</tt>, <tt>false</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forces failure.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>true</tt>, <tt>otherwise</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;always succeeds.<br>
  <tt>true/0</tt>&nbsp;could be defined as<br>
  <tt>&nbsp;&nbsp;&nbsp;&nbsp;true.</tt>
 </p>
 <p class="opsomming AutoStyle79">
  <tt>repeat</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;succeeds indefinitely many times on backtracking.<br>
  <tt>repeat/0</tt>&nbsp;could be defined as<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>repeat.<br>
   &nbsp;&nbsp;&nbsp;&nbsp;repeat:-repeat.</tt>
 </p>
 <p class="opsomming AutoStyle79">
  <tt>findall(X,G,L)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>L</tt> is a list of <tt>X</tt> &rsquo;s, one for each solution of <tt>G</tt> (succeeds with the empty list if no solutions are found).
 </p>
 <p class="opsomming AutoStyle79">
  <tt>bagof(X,G,L)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>L</tt> is a list of <tt>X</tt> &rsquo;s, one for each solution of <tt>G</tt>, which may be preceded by existential variables (fails if no solutions are found).
 </p>
 <p class="opsomming AutoStyle79">
  <tt>setof(X,G,L)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as <tt>bagof/3</tt>, but <tt>L</tt> is a sorted list without duplicates.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>forall(G,C)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for all the solutions of <tt>G</tt>, <tt>C</tt> is true.<br>
  <tt>forall/2</tt>&nbsp;could be defined as<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>forall(G,C):-not((G,not(C))).</tt>
 </p>
 <p class="sektie1">
  <i>Interaction</i>
 </p>
 <p class="opsomming AutoStyle79">
  <tt>read(Term)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Term</tt> is instantiated to the next line typed by the user (must be a Prolog term).
 </p>
 <p class="opsomming AutoStyle79">
  <tt>write(Term)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write <tt>Term</tt> to the screen.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>tab(N)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write <tt>N</tt> spaces to the screen.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>nl</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write a newline to the screen.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>get(C)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>C</tt> is ASCII code of next character typed by the user.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>put(C)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write character with ASCII code <tt>C</tt> to the screen.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>tell(File)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redirect output to <tt>File</tt>.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>told</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stop redirecting output.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>see(File)</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redirect input from <tt>File</tt>.
 </p>
 <p class="opsomming AutoStyle79">
  <tt>seen</tt>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stop redirecting input.
 </p>
 <b>
  <span class="AutoStyle80">
   <br clear="all"/>
  </span>
 </b>
 <h3 id="a_library_of_utility_predicates">
  A.2&nbsp;&nbsp;A library of utility predicates
 </h3>
 <p class="sektie1">
  What follows is a small collection of predicates that are used by various programs throughout the book.
 </p>
 <p class="sektie1">
  <i>Lists and sets</i>.&nbsp;&nbsp;We start with a couple of simple list predicates.
 </p>
 <p class="oms-eerst">
  % element(X,Ys) &lt;- X is an element of the list Ys
 </p>
 <p class="pi">
  element(X,[X|Ys]).
 </p>
 <p class="pi-laatst">
  element(X,[Y|Ys]):-<br>
  element(X,Ys).
</p>
 <p class="oms">
  % append(Xs,Ys,Zs) &lt;- list Zs is Xs followed by Ys
 </p>
 <p class="pi">
  append([],Ys,Ys).
 </p>
 <p class="pi-laatst">
  append([X|Xs],Ys,[X|Zs]):-<br>
  append(Xs,Ys,Zs).
</p>
 <p class="oms">
  % remove_one(X,Ys,Zs) &lt;- Zs is list Ys minus<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one occurrence of X
</p>
 <p class="pi">
  remove_one(X,[X|Ys],Ys).
 </p>
 <p class="pi-laatst">
  remove_one(X,[Y|Ys],[Y|Zs]):-<br>
  remove_one(X,Ys,Zs).
</p>
 <p class="tekst">
  The difference between lists and sets is that the order of elements in a set is not important. Thus, a <i>subset</i> is different from a <i>sublist</i>. The predicate <tt>proper_subset/2</tt> works only if the first argument is a list without duplicates!
 </p>
 <p class="oms-eerst">
  % subset(Xs,Ys) &lt;- every element of Xs occurs in Ys
 </p>
 <p class="pi">
  subset([],Ys).
 </p>
 <p class="pi-laatst">
  subset([X|Xs],Ys):-<br>
  element(X,Ys),<br>
  subset(Xs,Ys).
</p>
 <p class="oms">
  % proper_subset(Xs,Ys) &lt;- Xs is a subset of Ys, and Ys<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has more elements than Xs
</p>
 <p class="pi">
  proper_subset([],Ys):-<br>
  Ys \= [].
</p>
 <p class="pi-laatst">
  proper_subset([X|Xs],Ys):-<br>
  remove_one(X,Ys,Ys1),<br>
  proper_subset(Xs,Ys1).
</p>
 <p class="tekst">
  The following three predicates use syntactic identity rather than unification, which is useful for lists containing variables.
 </p>
 <p class="pi-eerst">
  var_element(X,[Y|Ys]):-<br>
  X == Y.&nbsp;&nbsp;&nbsp;% syntactic identity
</p>
 <p class="pi-laatst">
  var_element(X,[Y|Ys]):-<br>
  var_element(X,Ys).
</p>
 <p class="pi">
  var_remove_one(X,[Y|Ys],Ys):-<br>
  X == Y.&nbsp;&nbsp;&nbsp;% syntactic identity
</p>
 <p class="pi-laatst">
  var_remove_one(X,[Y|Ys],[Y|Zs]):-<br>
  var_remove_one(X,Ys,Zs).
</p>
 <p class="pi">
  var_proper_subset([],Ys):-<br>
  Ys \= [].
</p>
 <p class="pi-laatst">
  var_proper_subset([X|Xs],Ys):-<br>
  var_remove_one(X,Ys,Zs),<br>
  var_proper_subset(Xs,Zs).
</p>
 <p class="sektie1">
  <i>Conjunctions and disjunctions.&nbsp;&nbsp;</i> Conjunctions and disjunctions are recursive datastructures, just like lists. However, whereas a single-element list such <tt>[1]</tt> is a complex term <tt>.(1,[])</tt>, a single-element conjunction or disjunction is a simple term. Therefore, each of the following predicates needs an extra clause for the single-element case. Note that <tt>true</tt> is the empty conjunction, while <tt>false</tt> represents the empty disjunction.
 </p>
 <p class="pi-eerst">
  disj_element(X,X):-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% single-element disjunction<br>
  not X=false,<br>
  not X=(One;TheOther).
</p>
 <p class="pi">
  disj_element(X,(X;Ys)).
 </p>
 <p class="pi-laatst">
  disj_element(X,(Y;Ys)):-<br>
  disj_element(X,Ys).
</p>
 <p class="pi">
  conj_append(true,Ys,Ys).
 </p>
 <p class="pi">
  conj_append(X,Ys,(X,Ys)):-&nbsp;&nbsp;&nbsp;% single-element conjunction<br>
  not X=true,<br>
  not X=(One,TheOther).
</p>
 <p class="pi-laatst">
  conj_append((X,Xs),Ys,(X,Zs)):-<br>
  conj_append(Xs,Ys,Zs).
</p>
 <p class="pi">
  disj_append(false,Ys,Ys).
 </p>
 <p class="pi">
  disj_append(X,Ys,(X;Ys)):-&nbsp;&nbsp;&nbsp;% single-element disjunction<br>
  not X=false,<br>
  not X=(One;TheOther).
</p>
 <p class="pi-laatst">
  disj_append((X;Xs),Ys,(X;Zs)):-<br>
  disj_append(Xs,Ys,Zs).
</p>
 <p class="pi">
  conj_remove_one(X,X,true):-&nbsp;&nbsp;% single-element conjunction<br>
  not X=true,<br>
  not X=(One,TheOther).
</p>
 <p class="pi">
  conj_remove_one(X,(X,Ys),Ys).
 </p>
 <p class="pi-laatst">
  conj_remove_one(X,(Y,Ys),(Y,Zs)):-<br>
  conj_remove_one(X,Ys,Zs).
</p>
 <p class="sektie1">
  <i>Preventing variables from getting instantiated.&nbsp;&nbsp;</i> Whenever Prolog reads a clause from its internal database, fresh copies of the variables in the clause are created. When a meta-interpreter uses an internal list of clauses, this is desirable as well. The predicate <tt>copy_term/2</tt> uses the internal database to create a fresh copy of any term. <tt>copy_element/2</tt> uses <tt>copy_term/2</tt> to create a fresh copy of an item in a list.
 </p>
 <p class="oms-eerst">
  % copy_term(Old,New) &lt;- New is a copy of Old<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with new variables
</p>
 <p class="pi">
  copy_term(Old,New):-<br>
  asserta('$copy'(Old)),<br>
  retract('$copy'(New)),!.
</p>
 <p class="pi-laatst">
  copy_term(Old,New):-&nbsp;&nbsp;&nbsp;% in case Old and New don&rsquo;t unify<br>
  retract('$copy'(Old)),<br>
  !,fail.
</p>
 <p class="oms-eerst">
  % copy_element(X,L) &lt;- X is an element of L<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with new variables
</p>
 <p class="pi-laatst">
  copy_element(X,Ys):-<br>
  element(X1,Ys),<br>
  copy_term(X1,X).
</p>
 <p class="tekst">
  <tt>try/1</tt> is a meta-predicate which tests whether a goal succeeds, without returning an answer-substitution. This is achieved by taking advantage of the difference between negation as failure and logical negation.
 </p>
 <p class="oms-eerst">
  % try(Goal) &lt;- Goal succeeds, but variables<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;don&rsquo;t get instantiated
</p>
 <p class="pi-laatst">
  try(Goal):-<br>
  not not Goal.
</p>
 <p class="sektie1">
  <i>Various.&nbsp;&nbsp;</i> The remaining predicates speak for themselves.
 </p>
 <p class="oms-eerst">
  % variant of setof/3 which succeeds with the empty list<br>
  % if no solutions can be found
</p>
 <p class="pi">
  setof0(X,G,L):-<br>
  setof(X,G,L),!.
</p>
 <p class="pi-laatst">
  setof0(X,G,[]).
 </p>
 <p class="oms">
  % same_predicate(L1,L2) &lt;- literals L1 and L2 have<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the same predicate and arity
</p>
 <p class="pi-laatst">
  same_predicate(L1,L2):-<br>
  functor(L1,P,N),<br>
  functor(L2,P,N).
</p>
</div>
<b>
 <span class="AutoStyle78">
  <br clear="all"/>
 </span>
</b>
<div class="WordSection3">
 <p class="cijfer" id="two_programs_for_logical_conversion">
  B
 </p>
 <h2 id="h_two_programs_for_logical_conversion">
  Two programs for logical conversion
 </h2>
 <p class="sektie1">
  The program in appendix B.1 transforms a formula in first-order Predicate Logic to clausal form, as described in section 2.5. The program in appendix B.2 completes a given set of general clauses by means of Predicate Completion (section 8.2). The output of this program is a formula in Predicate Logic, which can be transformed back to clausal form by means of the first program.
 </p>
 <h3 id="from_predicate_logic_to_clausal_logic">
  B.1&nbsp;&nbsp;&nbsp;From Predicate Logic to clausal logic
 </h3>
 <p class="sektie1">
  In section 2.5 we discussed a method for transforming a formula in Predicate Logic to an &lsquo;almost&rsquo; equivalent set of clauses (reread this section if you don&rsquo;t recall in what sense the clauses differ from the Predicate Logic formula). Below, a Prolog program implementing this method is given.
 </p>
 <p class="sektie">
  The logical symbols used in Predicate Logic formulas are defined as operators:
 </p>
 <p class="pi-eerst">
  % logical symbols used in Predicate Logic formulas
 </p>
 <p class="pi">
  :-op(900,xfx,'=&gt;').&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% implication
 </p>
 <p class="pi">
  :-op(800,xfy,&amp;).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% conjunction
 </p>
 <p class="pi">
  :-op(800,xfy,v).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% disjunction
 </p>
 <p class="pi-laatst">
  :-op(400,fy,-).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% negation
 </p>
 <p class="tekst">
  In addition, a universally quantified formula of the form
  <span class="AutoStyle09">
   &forall;
  </span>
  <tt>X:F</tt> is represented by the term <tt>forall(X,F)</tt>. For instance, the formula
 </p>
 <p class="p-el">
  <span class="AutoStyle09">
   &forall;
  </span>
  S: student_of(S,peter)
  <span class="AutoStyle09">
   &rarr;
  </span>
  likes(peter,S)
 </p>
 <p class="tekst">
  is represented by
 </p>
 <p class="p-el">
  forall(S,student_of(peter)=&gt;likes(peter,S)).
 </p>
 <p class="tekst">
  Likewise, an existentially quantified formula of the form
  <span class="AutoStyle09">
   &exist;
  </span>
  <tt>X:F</tt> is represented by the term <tt>exists(X,F)</tt>.
 </p>
 <p class="sektie">
  The tranformation from Predicate Logic to clausal logic requires six steps:
 </p>
 <p class="opsomming AutoStyle50">
  (<i>i</i>)&nbsp;&nbsp;&nbsp;replace implications by disjunction and negation;
 </p>
 <p class="opsomming">
  (<i>ii</i>)&nbsp;&nbsp;push negations inside, so that each of them immediately precedes a literal;
 </p>
 <p class="opsomming">
  (<i>iii</i>)&nbsp;move quantifiers to the front (the result is said to be in <i>prenex normal form</i>);
 </p>
 <p class="opsomming">
  (<i>iv</i>)&nbsp;replace existentially quantified variables by Skolem functors;
 </p>
 <p class="opsomming">
  (<i>v</i>)&nbsp;&nbsp;rewrite into <i>conjunctive normal form</i>, i.e. a conjunction of disjunctions of literals;
 </p>
 <p class="opsomming AutoStyle45">
  (<i>vi</i>)&nbsp;rewrite each conjunct to a clause.
 </p>
 <p class="tekst">
  The main predicate <tt>transform/2</tt>&nbsp;carries out these six steps:
 </p>
 <p class="pi-el">
  transform(Formula,Clauses):-<br>
  rewrite_implications(Formula,F1),<br>
  negations_inside(F1,F2),<br>
  prenex_normal_form(F2,F3),<br>
  skolemise(F3,F4),<br>
  conjunctive_normal_form(F4,F5),<br>
  clausal_form(F5,Clauses).
</p>
 <p class="tekst">
  Predicates for each of these steps are defined below.
 </p>
 <p class="sektie">
  The first two predicates contain one clause for each possible form a formula could have.
 </p>
 <p class="oms-eerst">
  % rewrite_implications(F1,F2) &lt;- F2 is a PL formula<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;without implications,<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log. equivalent with F1
</p>
 <p class="pi">
  rewrite_implications(A,A):-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% base case<br>
  literal(A).
</p>
 <p class="pi">
  rewrite_implications(A =&gt; B, -C v D):-% implication<br>
  rewrite_implications(A,C),<br>
  rewrite_implications(B,D).
</p>
 <p class="pi">
  rewrite_implications(A &amp; B, C &amp; D):-&nbsp;&nbsp;% no change;<br>
  rewrite_implications(A,C),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% try rest of<br>
  rewrite_implications(B,D).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% formula
</p>
 <p class="pi">
  rewrite_implications(A v B, C v D):-<br>
  rewrite_implications(A,C),<br>
  rewrite_implications(B,D).
</p>
 <p class="pi">
  rewrite_implications(-A,-C):-<br>
  rewrite_implications(A,C).
</p>
 <p class="pi">
  rewrite_implications(forall(X,B), forall(X,D)):-<br>
  rewrite_implications(B,D).
</p>
 <p class="pi-laatst">
  rewrite_implications(exists(X,B), exists(X,D)):-<br>
  rewrite_implications(B,D).
</p>
 <p class="oms">
  % negations_inside(F1,F2) &lt;- F2 is a PL formula with<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;negs. only preceding literals<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log. equivalent with F1
</p>
 <p class="pi">
  negations_inside(A,A):-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% base case<br>
  literal(A).
</p>
 <p class="pi">
  negations_inside(-(A &amp; B), C v D):-&nbsp;&nbsp;&nbsp;% De Morgan (1)<br>
  negations_inside(-A,C),<br>
  negations_inside(-B,D).
</p>
 <p class="pi">
  negations_inside(-(A v B), C &amp;&nbsp;D):-&nbsp;&nbsp;% De Morgan (2)<br>
  negations_inside(-A,C),<br>
  negations_inside(-B,D).
</p>
 <p class="pi">
  negations_inside(-(-A),B):-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% double negation<br>
  negations_inside(A,B).
</p>
 <p class="pi">
  negations_inside(-exists(X,A),forall(X,B)):-&nbsp;% quantifiers<br>
  negations_inside(-A,B).
</p>
 <p class="pi">
  negations_inside(-forall(X,A),exists(X,B)):-<br>
  negations_inside(-A,B).
</p>
 <p class="pi">
  negations_inside(A &amp; B, C &amp; D):-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% no change;<br>
  negations_inside(A,C),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% try rest of<br>
  negations_inside(B,D).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% formula
</p>
 <p class="pi">
  negations_inside(A v B, C v&nbsp;D):-<br>
  negations_inside(A,C),<br>
  negations_inside(B,D).
</p>
 <p class="pi">
  negations_inside(exists(X,A),exists(X,B)):-<br>
  negations_inside(A,B).
</p>
 <p class="pi-laatst">
  negations_inside(forall(X,A),forall(X,B)):-<br>
  negations_inside(A,B).
</p>
 <p class="sektie">
  In step (<i>iii</i>), the quantifiers found at different positions in the formula are moved to the front, preserving their order. This is achieved by means of an auxiliary predicate <tt>pnf/4</tt>, which separates the quantifiers from the rest of the formula (referred to below as the <tt>Body</tt>). An additional argument <tt>V</tt> acts as a pointer to the place of the body in the quantifier structure. For instance, the query
 </p>
 <p class="p-el">
  ?-pnf(forall(X,p(X,X)) &amp; forall(Y,exists(Z,p(Y,Z))),Q,V,B)
 </p>
 <p class="tekst">
  has the following answers:
 </p>
 <p class="p-el">
  Q = forall(X,forall(Y,exists(Z,V)))<br>
  B = p(X,X)&amp;p(Y,Z)
</p>
 <p class="tekst">
  Unifying <tt>V</tt> with <tt>B</tt> gives the required formula in prenex normal form:
 </p>
 <p class="oms-eerst">
  % prenex_normal_form(F1,F2) &lt;- F2 is a PL formula<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with all quant.s in front,<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log. equivalent with F1
</p>
 <p class="pi-laatst">
  prenex_normal_form(F,PNF):-<br>
  pnf(F,PNF,B,B).
</p>
 <p class="pi">
  pnf(A,V,V,A):-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% base case<br>
  literal(A).
</p>
 <p class="pi">
  pnf(forall(X,F),forall(X,Quants),V,Body):-<br>
  pnf(F,Quants,V,Body).
</p>
 <p class="pi">
  pnf(exists(X,F),exists(X,Quants),V,Body):-<br>
  pnf(F,Quants,V,Body).
</p>
 <p class="pi">
  pnf(A &amp; B,Quants,V,BodyA &amp; BodyB):-<br>
  pnf(A,Quants,QB,BodyA),<br>
  pnf(B,QB,V,BodyB).
</p>
 <p class="pi-laatst">
  pnf(A v B,Quants,V,BodyA v BodyB):-<br>
  pnf(A,Quants,QB,BodyA),<br>
  pnf(B,QB,V,BodyB).
</p>
 <p class="sektie">
  Step (<i>iv</i>) is called <i>Skolemisation</i>. It involves introducing a Skolem functor&nbsp;for each existentially quantified variable. The Skolem functors are named <tt>sk1</tt>, <tt>sk2</tt>, etc. The arguments of the Skolem functors are given by the universally quantified variables found before the existentially quantified one. Since all remaining variables are universally quantified, the universal quantifiers can be dropped. (Strictly speaking, the formula is now neither in Predicate Logic form, nor in clausal form.)
 </p>
 <p class="oms-eerst">
  % skolemise(F1,F2) &lt;- F2 is obtained from F1 by replacing<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;all existentially quantified<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variables by Skolem terms
</p>
 <p class="pi-laatst">
  skolemise(F1,F2):-<br>
  skolemise(F1,[],1,F2).
</p>
 <p class="pi">
  skolemise(forall(X,F1),VarList,N,F2):-!,% remove univ.<br>
  skolemise(F1,[X|VarList],N,F2).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% quantifier
</p>
 <p class="pi">
  skolemise(exists(X,F1),VarList,N,F2):-!,<br>
  skolem_term(X,VarList,N),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% unify with<br>
  N1 is N+1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% Skolem term<br>
  skolemise(F1,VarList,N1,F2).
</p>
 <p class="pi-laatst">
  skolemise(F,V,N,F).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% copy rest of formula
 </p>
 <p class="pi-laatst">
  skolem_term(X,VarList,N):-<br>
  C is N+48,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% number -&gt; character<br>
  name(Functor,[115,107,C]),&nbsp;&nbsp;&nbsp;% Skolem functor skN<br>
  X =.. [Functor|VarList].
</p>
 <p class="sektie">
  We now have a formula containing only conjunction, disjunction and positive and negative literals. Such a formula can uniquely be rewritten to a conjunction of disjunctions of literals, by distributing disjunction over conjunction. The result is said to be in <i>conjunctive normal form</i>&nbsp;(CNF):
 </p>
 <p class="pi-eerst">
  conjunctive_normal_form(A,A):-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% base case<br>
  disjunction_of_literals(A),!.
</p>
 <p class="pi">
  conjunctive_normal_form((A &amp; B) v C, D &amp; E ):-!,<br>
  conjunctive_normal_form(A v C,D),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% distribution<br>
  conjunctive_normal_form(B v C,E).
</p>
 <p class="pi">
  conjunctive_normal_form(A v (B &amp; C), D &amp; E ):- !,<br>
  conjunctive_normal_form(A v B,D),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% distribution<br>
  conjunctive_normal_form(A v C,E).
</p>
 <p class="pi">
  conjunctive_normal_form(A &amp; B,C &amp; D):-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% conjuction<br>
  conjunctive_normal_form(A,C),<br>
  conjunctive_normal_form(B,D).
</p>
 <p class="pi-laatst">
  conjunctive_normal_form(A v B,E):-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% other cases<br>
  conjunctive_normal_form(A,C),<br>
  conjunctive_normal_form(B,D),<br>
  conjunctive_normal_form(C v D,E).
</p>
 <p class="sektie">
  Finally, the CNF-formula is rewritten to a list of clauses. For simplicity, body and head of each clause are represented by lists:
 </p>
 <p class="pi-eerst">
  clausal_form(A,[Clause]):-<br>
  disjunction_of_literals(A),<br>
  make_clause(A,Clause).
</p>
 <p class="pi-laatst">
  clausal_form(A &amp; B,Clauses):-<br>
  clausal_form(A,ClausesA),<br>
  clausal_form(B,ClausesB),<br>
  append(ClausesA,ClausesB,Clauses).
</p>
 <p class="pi">
  make_clause(P,([P]:-[])):-<br>
  logical_atom(P).
</p>
 <p class="pi">
  make_clause(-N,([]:-[N])):-<br>
  logical_atom(N).
</p>
 <p class="pi-laatst">
  make_clause(A v B,(HeadAB:-BodyAB)):-<br>
  make_clause(A,(HeadA:-BodyA)),<br>
  make_clause(B,(HeadB:-BodyB)),<br>
  append(HeadA,HeadB,HeadAB),<br>
  append(BodyA,BodyB,BodyAB).
</p>
 <p class="tekst">
  The program is completed by a number of simple utility predicates:
 </p>
 <p class="pi-eerst">
  disjunction_of_literals(A):-<br>
  literal(A).
</p>
 <p class="pi-laatst">
  disjunction_of_literals(C v D):-<br>
  disjunction_of_literals(C),<br>
  disjunction_of_literals(D).
</p>
 <p class="pi">
  literal(A):-<br>
  logical_atom(A).
</p>
 <p class="pi-laatst">
  literal(-A):-<br>
  logical_atom(A).
</p>
 <p class="pi-laatst">
  logical_atom(A):-<br>
  functor(A,P,N),<br>
  not logical_symbol(P).
</p>
 <p class="pi">
  logical_symbol(=&gt;).
 </p>
 <p class="pi">
  logical_symbol(&lt;=&gt;).
 </p>
 <p class="pi">
  logical_symbol(-).
 </p>
 <p class="pi">
  logical_symbol(&amp;).
 </p>
 <p class="pi">
  logical_symbol(v).
 </p>
 <p class="pi">
  logical_symbol(exists).
 </p>
 <p class="pi">
  logical_symbol(forall).
 </p>
 <h3 id="predicate_completion">
  B.2&nbsp;&nbsp;&nbsp;Predicate Completion
 </h3>
 <p class="sektie1">
  In section 8.2, we presented Predicate Completion&nbsp;as a technique for explicitly handling negative information. A logic program is viewed as a set of predicate definitions, where the only-if parts are implicitly assumed. Below, a program is given which constructs additional clauses representing the only-if parts.
 </p>
 <p class="sektie">
  A program is represented as a list of clauses, where head and body of each clause are lists of atoms, as in the program in the previous section. The output of the Predicate Completion program is a formula in first-order Predicate Logic, which can be transformed to clausal logic by means of the aforementioned program, if desired. Definitions for different predicates are handled separately, so the first step is to partition the program into separate predicate definitions. After completing each of these definitions we add appropriate formulas for each of the undefined predicates.
 </p>
 <p class="oms-eerst">
  % complete(P,F) &lt;- P is a list of predicate definitions,<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and F is a Predicate Logic formula<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;representing the only-if parts of P
</p>
 <p class="pi-laatst">
  complete(Program,Comp):-<br>
  separate_definitions(Program,Definitions),<br>
  complete_definitions(Definitions,CompDefs,Heads),<br>
  handle_undefined(Program,Heads,CompDefs,Comp).
</p>
 <p class="pi">
  separate_definitions([],[]).
 </p>
 <p class="pi-laatst">
  separate_definitions([([H]:-B)|Cls],[[([H]:-B)|D]|Ds]):-<br>
  get_definition(Cls,H,D,Rest),<br>
  separate_definitions(Rest,Ds).
</p>
 <p class="pi">
  get_definition([],Head,[],[]).
 </p>
 <p class="pi">
  get_definition([([H]:-B)|Cls],Head,[([H]:-B)|Def],Rest):-<br>
  same_predicate(H,Head),<br>
  get_definition(Cls,Head,Def,Rest).
</p>
 <p class="pi-laatst">
  get_definition([([H]:-B)|Cls],Head,Def,[([H]:-B)|Rest]):-<br>
  not same_predicate(H,Head),<br>
  get_definition(Cls,Head,Def,Rest).
</p>
 <p class="sektie">
  Undefined predicates are those which occur in bodies of clauses without occurring in any head. The list <tt>Heads</tt> of defined predicates is obtained while completing each predicate definition. Care must be taken to avoid considering <tt>not/1</tt> as an undefined predicate, and also to check the negated literal itself. After constructing the list of undefined literals occuring in clause bodies, each of them is transformed into a formula of the form
  <span class="AutoStyle09">
   &forall;
  </span>
  <tt>X1</tt> &hellip;
  <span class="AutoStyle09">
   &forall;
  </span>
  <tt>Xn:</tt> &not; <tt>p(X1,&hellip;,Xn)</tt>:
 </p>
 <p class="pi-el">
  handle_undefined(Program,Heads,CompDefs,Comp):-<br>
  findall(L,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( member((H:-B),Program),% pick a clause body<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( (member(L,B),not L=not(X))&nbsp;% unneg. lit.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; member(not L,B) ),&nbsp;&nbsp;&nbsp;% or a negated one<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not member(L,Heads) ),&nbsp;% which is undefined<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undefs),<br>
  undef_formulas(Undefs,CompDefs,Comp).
</p>
 <p class="pi">
  undef_formulas([],Comp,Comp).
 </p>
 <p class="pi-laatst">
  undef_formulas([L|Ls],Comp0,Comp):-<br>
  quantify(L,F),<br>
  undef_formulas(Ls,F &amp; Comp0,Comp).
</p>
 <p class="pi-laatst">
  quantify(L,F):-<br>
  L =.. [P|As],<br>
  variablise(As,Vs,F,-NewL),&nbsp;&nbsp;&nbsp;% NB. negation symbol!<br>
  NewL =.. [P|Vs].&nbsp;&nbsp;&nbsp;&nbsp;% turn arguments into variables
</p>
 <p class="pi">
  % add quantifiers
 </p>
 <p class="pi">
  variablise([],[],L,L).
 </p>
 <p class="pi-laatst">
  variablise([A|As],[V|Vs],forall(V,F),L):-<br>
  variablise(As,Vs,F,L).
</p>
 <p class="sektie">
  The main task in Predicate Completion is the completion of each separate predicate definition. The main steps are
 </p>
 <p class="opsomming AutoStyle50">
  (<i>i</i>)&nbsp;&nbsp;&nbsp;adding explicit unifications to the body of clauses;
 </p>
 <p class="opsomming">
  (<i>ii</i>)&nbsp;&nbsp;adding existential quantifiers for those variables occurring in the body of a clause but not in its head;
 </p>
 <p class="opsomming AutoStyle45">
  (<i>iii</i>)&nbsp;combining the clauses into one formula, and adding universal quantifiers for the head variables.
 </p>
 <p class="tekst">
  The predicate <tt>unifications_and_quantifiers/2</tt> takes care of the first two steps, and the third step is carried out by the predicate <tt>complete_formula/3</tt>. These predicates are relatively self-explanatory:
 </p>
 <p class="oms-eerst">
  % complete_definitions(D,C,H) &lt;- C is the complement of<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;definitions D, and H is<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list of variablised heads
</p>
 <p class="pi">
  complete_definitions([Def],Comp,[Head]):-!,<br>
  complete_definition(Def,Comp,Head).
</p>
 <p class="pi-laatst">
  complete_definitions([Def|Defs],Comp &amp; Comps,[H|Hs]):-<br>
  complete_definition(Def,Comp,H),<br>
  complete_definitions(Defs,Comps,Hs).
</p>
 <p class="pi-laatst">
  complete_definition(Definition,Comp,Head):-<br>
  unifications_and_quantifiers(Definition,F),<br>
  complete_formula(F,Comp,Head).
</p>
 <p class="pi">
  unifications_and_quantifiers([],[]).
 </p>
 <p class="pi-laatst">
  unifications_and_quantifiers([Clause|Clauses],[C|Cs]):-<br>
  unifs_and_quants(Clause,C),<br>
  unifications_and_quantifiers(Clauses,Cs).
</p>
 <p class="pi-laatst">
  unifs_and_quants(([Head]:-Body),([NewHead]:-NewBody)):-<br>
  Head=..[Pred|Args],<br>
  explicit_unifications(Args,NewArgs,Body,TmpBody),<br>
  existential_quantifiers(TmpBody,NewArgs,NewBody),<br>
  NewHead=..[Pred|NewArgs].
</p>
 <p class="oms-eerst">
  % explicit_unifications(A,NA,B,NB) &lt;- NA is list A with<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;non-var. terms replaced by new<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var.s; NB is body B extended<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with explicit unifications
</p>
 <p class="pi">
  explicit_unifications([],[],Body,Body).
 </p>
 <p class="pi">
  explicit_unifications([T|As],[V|NewAs],B,[V=T|NewB]):-<br>
  nonvar(T),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% add explicit unification<br>
  explicit_unifications(As,NewAs,B,NewB).
</p>
 <p class="pi-laatst">
  explicit_unifications([Var|As],[Var|NewAs],Body,NewBody):-<br>
  var(Var),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% no expl. unific. needed<br>
  explicit_unifications(Args,NewArgs,Body,NewBody).
</p>
 <p class="oms">
  % existential_quantifiers(B,V,NB) &lt;- NB is conj. of lit.s<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in B, extended by ex. quant.s<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for var.s in B but not in V
</p>
 <p class="pi-laatst">
  existential_quantifiers(Body,HeadVars,NewBody):-<br>
  varsin(Body,BodyVars),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% built-in predicate<br>
  body_form(Body,Conj),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% list -&gt; conjunction<br>
  body_quants(BodyVars,HeadVars,Conj,NewBody).
</p>
 <p class="pi">
  body_form([not Lit],-Lit):-!.
 </p>
 <p class="pi">
  body_form([Lit],Lit):-!.
 </p>
 <p class="pi">
  body_form([not Lit|List],-Lit &amp; Conj):-!,<br>
  body_form(List,Conj).
</p>
 <p class="pi-laatst">
  body_form([Lit|List],Lit &amp; Conj):-<br>
  body_form(List,Conj).
</p>
 <p class="oms">
  % body_quants(BV,HV,C,QC) &lt;- QC is conj. C extended with<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;existential quant.s for all<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variables in BV but not in HV
</p>
 <p class="pi">
  body_quants([],HeadVars,Conj,Conj).
 </p>
 <p class="pi">
  body_quants([BVar|BVars],HeadVars,Conj,exists(BVar,F)):-<br>
  not var_element(BVar,HeadVars),<br>
  body_quants(BVars,HeadVars,Conj,F).
</p>
 <p class="pi-laatst">
  body_quants([BVar|BVars],HeadVars,Conj,F):-<br>
  var_element(BVar,HeadVars),<br>
  body_quants(BVars,HeadVars,Conj,F).
</p>
 <p class="oms">
  % complete_formula(C,F,H) &lt;- F is disjunction of bodies<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of clauses in C, and univ.<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quantified head H
</p>
 <p class="pi-laatst">
  complete_formula(C,Formula,Head):-<br>
  combine_clauses(C,Head,Body),<br>
  varsin(Head,HeadVars),<br>
  head_quants(HeadVars,Head =&gt; Body,Formula).
</p>
 <p class="pi">
  combine_clauses([([Head]:-Body)],Head,Body):- !.
 </p>
 <p class="pi-laatst">
  combine_clauses([([Head]:-Body)|R],Head,Body v RBody):-<br>
  combine_clauses(R,Head,RBody).
</p>
 <p class="pi">
  head_quants([],Formula,Formula).
 </p>
 <p class="pi-laatst">
  head_quants([HVar|HVars],Formula,forall(HVar,F)):-<br>
  head_quants(HVars,Formula,F).
</p>
 <p class="sektie">
  The following query illustrates the operation of the program, and shows also how it can be combined with the program for conversion to clausal form presented in the previous section.
 </p>
 <p class="query">
  ?-P=[([bird(tweety)]:-[]),<br>
  &nbsp;&nbsp;([flies(X)]:-[bird(X),not abnormal(X)])],<br>
  complete(P,F),<br>
  transform(F,C).
</p>
 <p class="query">
  F=forall(Y,-abnormal(Y)) &amp;<br>
  forall(Z,bird(Z) =&gt; Z=tweety) &amp;<br>
  forall(X,flies(X) =&gt; bird(X) &amp; -abnormal(X))
</p>
 <p class="query">
  C=[([]:-[abnormal(Y)]),<br>
  &nbsp;([Z=tweety]:-[bird(Z)]),<br>
  &nbsp;([bird(X)]:-[flies(X)]),<br>
  &nbsp;([]:-[flies(X),abnormal(X)])]
</p>
</div>
<span class="AutoStyle81">
 <br clear="all"/>
</span>
<div class="WordSection4">
 <p class="cijfer" id="answers_to_selected_exercises">
  C
 </p>
 <h2 id="h_answers_to_selected_exercises">
  Answers to selected exercises
 </h2>
 <p class="sektie1">
  Below, answers to selected exercises can be found. Not all answers have been included, due to two reasons. Some of the questions only lead to a new insight when the answer is actually constructed, and the student is encouraged to do so. Furthermore, some other questions embody small programming projects, and don&rsquo;t have straightforward answers.
 </p>
 <p class="sektie">
  The remaining questions have been constructed to highlight a particular point in the discussion (which, incidentally, is the reason that they are printed throughout the text, and not at the end of each chapter). They are most advantageous when addressed as soon as they are encountered. The answers provided here can then be used to check and assess one&rsquo;s own solution. Most of the answers contain additional explanatory remarks.
 </p>
 <p class="sektie">
  Alternatively, this appendix can be read separately, after the previous chapters have been studied. To this end, some of the questions have been reformulated so as to minimise references to the original text.
 </p>
 <h3 id="a_brief_introduction_to_clausal_logic_c">
  C.1&nbsp;&nbsp;A brief introduction to clausal logic
 </h3>
<div class="extract exercise" id="a_1.2">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 1.2.</i> Construct the proof   trees for the query<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>?-nearby(W,charing_cross)</tt>.
      </p>
     </div>
</div>
 <p class="answer">
  There are six answers to this query:
 </p>
 <p class="p-el">
  <span class="AutoStyle25">
   {
  </span>
  W
  <span class="AutoStyle09">
   &rarr;
  </span>
  green_park
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  W
  <span class="AutoStyle09">
   &rarr;
  </span>
  piccadilly_circus
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  W
  <span class="AutoStyle09">
   &rarr;
  </span>
  leicester_square
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  W
  <span class="AutoStyle09">
   &rarr;
  </span>
  bond_street
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  W
  <span class="AutoStyle09">
   &rarr;
  </span>
  oxford_circus
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  W
  <span class="AutoStyle09">
   &rarr;
  </span>
  tottenham_court_road
  <span class="AutoStyle25">
   }
  </span>
 </p>
 <p class="tekst">
  The proof trees for the first three answers are analogous to fig. 1.2. The proof tree for the fourth answer is given below (the two remaining proof trees are similar):
 </p>
<div class="extract figure" id="a.1">
 <p class="figure">
  <img src="img/part_a/image002.svg" v:shapes="Picture_x0020_1" width="70%">
  </img>
 </p>
 </div>
<div class="extract exercise" id="a_1.4">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 1.4.</i> A list is either the   empty list <tt>[]</tt>, or a non-empty list <tt>[First|Rest]</tt> where <tt>Rest</tt> is a list. Define a   relation <tt>list(L)</tt>, which checks whether <tt>L</tt> is a list. Adapt it such that it succeeds   only for lists of (<i>i</i>) even length   and (<i>ii</i>) odd length.
      </p>
     </div>
</div>
 <p class="answer">
  The first specification can immediately be translated to Prolog:
 </p>
 <p class="pi-eerst">
  list([]).
 </p>
 <p class="pi-laatst">
  list([First|Rest]):-list(Rest).
 </p>
 <p class="tekst">
  A list of even length is either the empty list, or a non-empty list with two more elements than the next shorter list of even length:
 </p>
 <p class="pi-eerst">
  evenlist([]).
 </p>
 <p class="pi-laatst">
  evenlist([First,Second|Rest]):-evenlist(Rest).
 </p>
 <p class="tekst">
  In order to adapt this definition for lists of odd length, only the non-recursive clause needs to be changed:
 </p>
 <p class="pi-eerst">
  oddlist([One]).
 </p>
 <p class="pi-laatst">
  oddlist([First,Second|Rest]):-oddlist(Rest).
 </p>
 <p class="tekst">
  Notice that <tt>oddlist</tt> can also be defined in terms of <tt>evenlist</tt> (or <i>vice versa</i>):
 </p>
 <p class="p-el">
  oddlist([First|Rest]):-evenlist(Rest).
 </p>
<div class="extract exercise" id="a_1.5">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 1.5.</i> Construct a query asking   for a route from Bond Street to Piccadilly Circus with at least two   intermediate stations.
      </p>
     </div>
</div>
 <p class="p-el">
  ?-reachable(bond_street,piccadilly_circus,[S1,S2|Rest]).
 </p>
 <h3 id="clausal_logic_and_resolution_theoretical_backgrounds_c">
  C.2&nbsp;&nbsp;Clausal logic and resolution: theoretical backgrounds
 </h3>
<div class="extract exercise" id="a_2.1">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.1.</i> Translate the following   statements into clauses, using the atoms <tt>person</tt>, <tt>sad</tt> and <tt>happy</tt>:<br>
       (<i>a</i>)&nbsp;&nbsp;&nbsp;&nbsp;persons   are happy or sad;<br>
        (<i>b</i>)&nbsp;&nbsp;&nbsp;&nbsp;no   person is both happy and sad;<br>
         (<i>c</i>)&nbsp;&nbsp;&nbsp;&nbsp;sad   persons are not happy;<br>
          (<i>d</i>)&nbsp;&nbsp;&nbsp;&nbsp;non-happy   persons are sad.
</p>
     </div>
</div>
 <p class="answer">
  The statements should be read as &lsquo; <b>if</b> &hellip; <b>then</b> &hellip;&rsquo; statements. Thus, the first statement reads &lsquo; <b>if</b> somebody is a person, <b>then</b> she is happy or sad&rsquo;:
 </p>
 <p class="opsomming">
  (<i>a</i>)&nbsp;&nbsp;&nbsp;<tt>happy;sad:-person</tt>
 </p>
 <p class="tekst">
  The second statement reads &lsquo; <b>if</b> somebody is a person, <b>then</b> she is not both happy and sad&rsquo;. In clausal logic, only positive conclusions can be drawn; negative conclusions are turned into positive conditions, as follows: &lsquo; <b>if</b> somebody is a person, and she is happy and sad, <b>then</b> contradiction&rsquo;. A contradictory conclusion is signalled by the empty head:
 </p>
 <p class="opsomming">
  (<i>b</i>)&nbsp;&nbsp;<tt>:-person,happy,sad</tt>
 </p>
 <p class="tekst">
  Following the same recipe, the third statement expresses that &lsquo; <b>if</b> somebody is a person who is sad, and she is happy, <b>then</b> contradiction&rsquo;:
 </p>
 <p class="opsomming">
  (<i>c</i>)&nbsp;&nbsp;&nbsp;<tt>:-person,sad,happy</tt>
 </p>
 <p class="tekst">
  Thus, sentences (<i>b</i>) and (<i>c</i>) convey the same logical meaning.
 </p>
 <p class="sektie">
  Finally, the fourth sentence reads &lsquo; <b>if</b> somebody is a person who is not happy, <b>then</b> she is sad&rsquo;. In clausal logic, only positive conditions can be used; therefore, this negative condition should be turned into a positive conclusion: &lsquo; <b>if</b> somebody is a person, <b>then</b> she is sad or happy&rsquo;. We thus obtain the same clause as in case (<i>a</i>):
 </p>
 <p class="opsomming">
  (<i>d</i>)&nbsp;&nbsp;&nbsp;<tt>sad;happy:-person</tt>
 </p>
<div class="extract exercise" id="a_2.2">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.2.</i> Given the program<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>married;bachelor:-man,adult.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;man.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:-bachelor.</tt><br>
determine which of the following clauses are logical consequences of this   program:<br>
(<i>a</i>)&nbsp;&nbsp;&nbsp;&nbsp;<tt>married:-adult</tt>;<br>
       (<i>b</i>)&nbsp;&nbsp;&nbsp;&nbsp;<tt>married:-bachelor</tt>;<br>
       (<i>c</i>)&nbsp;&nbsp;&nbsp;&nbsp;<tt>bachelor:-man</tt>;<br>
       (<i>d</i>)&nbsp;&nbsp;&nbsp;&nbsp;<tt>bachelor:-bachelor</tt>.
      </p>
     </div>
</div>
 <p class="answer">
  (<i>a</i>) Any model of the first clause, which additionally makes <tt>man</tt> <b>true</b>, is also a model of the clause <tt>married;bachelor:-adult</tt>. Likewise, any model of this clause which additionally makes <tt>bachelor</tt> <b>false</b> is also a model of the clause <tt>married:-adult</tt>, which is therefore a logical consequence of the program.
 </p>
 <p class="sektie">
  (<i>b</i>) The body of this clause is <b>false</b> in any model of the program, and therefore the clause is <b>true</b> in any such model.
 </p>
 <p class="sektie">
  (<i>c</i>) The body of this clause is <b>true</b> in any model of the program, while its head is <b>false</b>. The clause is therefore not a logical consequence of the program (on the contrary, it is <b>false</b> in every model of the program, not just in some).
 </p>
 <p class="sektie">
  (<i>d</i>) This clause is a <i>tautology</i>: it is <b>true</b> in any interpretation, and therefore a logical consequence of any program.
 </p>
<div class="extract exercise" id="a_2.3">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.3.</i> Write down the six   Herbrand interpretations that are not models of the program<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;married;bachelor:-man,adult.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_wife:-man,married.</tt>
      </p>
     </div>
</div>
 <p class="answer">
  The six interpretations are:
 </p>
 <p class="p-el">
  <span class="AutoStyle25">
   {
  </span>
  man
  <span class="AutoStyle25">
   ,
  </span>
  adult
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  man
  <span class="AutoStyle25">
   ,
  </span>
  adult
  <span class="AutoStyle25">
   ,
  </span>
  has_wife
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  man
  <span class="AutoStyle25">
   ,
  </span>
  married
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  man
  <span class="AutoStyle25">
   ,
  </span>
  married
  <span class="AutoStyle25">
   ,
  </span>
  adult
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  man
  <span class="AutoStyle25">
   ,
  </span>
  married
  <span class="AutoStyle25">
   ,
  </span>
  bachelor
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  man
  <span class="AutoStyle25">
   ,
  </span>
  married
  <span class="AutoStyle25">
   ,
  </span>
  adult
  <span class="AutoStyle25">
   ,
  </span>
  bachelor
  <span class="AutoStyle25">
   }
  </span>
 </p>
 <p class="tekst">
  The first two interpretations satisfy the body of the first clause but violate its head; the remaining four interpretations satisfy the body of the second clause but violate its head.
 </p>
<div class="extract exercise" id="a_2.4">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.4.</i> Give a derivation of <tt>friendly</tt> from   the following program:<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>happy;friendly:-teacher.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;friendly:-teacher,happy.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;teacher;wise.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;teacher:-wise.</tt>
      </p>
     </div>
</div>
 <p class="answer">
  This requires derivations of the clauses <tt>friendly:-teacher</tt> and <tt>teacher</tt>:
 </p>
<div class="extract figure" id="a.2">
 <p class="figure">
  <img src="img/part_a/image004.svg" v:shapes="Picture_x0020_2" width="70%">
  </img>
 </p>
</div>
 <p class="tekst">
  Notice that this derivation&nbsp;can not be recast in the form of a linear tree, where each resolvent is obtained from the previous resolvent and a given clause, as in Chapter 1. This is due to the fact that some clauses are indefinite&nbsp;(have more than one positive literal).
 </p>
<div class="extract exercise" id="a_2.5">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.5.</i> Prove by refutation that <tt>friendly:-has_friends</tt> is a logical consequence of the following clauses:<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>happy:-has_friends.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;friendly:-happy.</tt>
      </p>
     </div>
</div>
 <p class="answer">
  The negation of <tt>friendly:-has_friends</tt> consists of two clauses, <tt>:‑friendly</tt> and <tt>has_friends</tt>. Together, these four clauses are inconsistent:
 </p>
<div class="extract figure" id="a.3">
 <p class="figure">
  <img src="img/part_a/image006.svg" v:shapes="Picture_x0020_3" width="35%">
  </img>
 </p>
</div>
<div class="extract exercise" id="a_2.6">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.6.</i> How many models does the   following clause have over the Herbrand universe { <tt>peter</tt>, <tt>maria</tt> }:<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>likes(peter,S):-student_of(S,peter)</tt>
      </p>
     </div>
</div>
 <p class="answer">
  The set of ground instances of this clause is
 </p>
 <p class="p-el AutoStyle34">
  <span class="AutoStyle25">
   {
  </span>
  likes(peter,maria):-student_of(maria,peter)
  <span class="AutoStyle25">
   ,
  </span><br>
  likes(peter,peter):-student_of(peter,peter)
<span class="AutoStyle25">
   }
  </span>
 </p>
 <p class="tekst">
  and the Herbrand base is
 </p>
 <p class="p-el AutoStyle30">
  <span class="AutoStyle25">
   {&nbsp;
  </span>
  likes(peter,peter)
  <span class="AutoStyle25">
   ,
  </span>
  likes(peter,maria)
  <span class="AutoStyle25">
   ,<br>
   </span>
  likes(maria,peter)
  <span class="AutoStyle25">
   ,
  </span>
  likes(maria,maria)
  <span class="AutoStyle25">
   ,<br>
   </span>
  student_of(peter,peter)
  <span class="AutoStyle25">
   ,
  </span>
  student_of(peter,maria)
  <span class="AutoStyle25">
   ,<br>
   </span>
  student_of(maria,peter)
  <span class="AutoStyle25">
   ,
  </span>
  student_of(maria,maria)
  <span class="AutoStyle25">
   }
  </span>
 </p>
 <p class="tekst">
  Only the left four ground atoms are relevant for determining whether an interpretation is a model. 9 out of 16 truth-value assignments to these ground atoms result in a model. Because of the 4 irrelevant ground atoms, this yields 9*2
  <span class="AutoStyle56">
   4
  </span>
  =144 models. Notice that this is a rather large number of models for such a modest Herbrand universe, and such a simple clause! This illustrates that <i>less knowledge leads to more models</i>.
 </p>
<div class="extract exercise" id="a_2.7">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.7</i>. Write a clause   expressing that Peter teaches all the first-year courses, and apply   resolution to this clause and the clause<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>likes(peter,maria):-follows(maria,C),teaches(peter,C)</tt>
      </p>
     </div>
</div>
 <p class="answer">
  This is expressed by the clause
 </p>
 <p class="p-el">
  teaches(peter,C):-first_year_course(C)
 </p>
 <p class="tekst">
  Resolution with the above clause yields
 </p>
 <p class="p-el">
  likes(peter,maria):-follows(maria,C),first_year_course(C)
 </p>
 <p class="tekst">
  In words: &lsquo;Peter likes Maria <b>if</b> Maria follows a first-year course&rsquo;.
 </p>
<div class="extract exercise" id="a_2.9">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.9</i>. Translate to clausal   logic:<br>
       (<i>a</i>)&nbsp;&nbsp;&nbsp;&nbsp;every   mouse has a tail;<br>
        (<i>b</i>)&nbsp;&nbsp;&nbsp;&nbsp;somebody   loves everybody;<br>
         (<i>c</i>)&nbsp;&nbsp;&nbsp;&nbsp;every   two numbers have a maximum.
</p>
     </div>
</div>
 <p class="answer">
  (<i>a</i>) This statement should be read as &lsquo; <b>if</b> <i>X</i> is a mouse, <b>then</b> there exists something which is <i>X</i> &rsquo;s tail&rsquo;. Giving <i>X</i> &rsquo;s tail the abstract name <tt>tail(X)</tt>, we obtain the following clause:
 </p>
 <p class="p-el">
  tail_of(tail(X),X):-mouse(X)
 </p>
 <p class="sektie">
  (<i>b</i>) Here we need to give the person who loves everybody an abstract name. Since this person does not depend on anybody else, it can simply be a constant:
 </p>
 <p class="p-el">
  loves(person_who_loves_everybody,X)
 </p>
 <p class="tekst">
  Notice the difference with the statement &lsquo;everybody loves somebody&rsquo;:
 </p>
 <p class="p-el">
  loves(X,person_loved_by(X))
 </p>
 <p class="sektie">
  (<i>c</i>) This statement should be read as &lsquo; <b>if</b> <i>X</i> and <i>Y</i> are numbers, then there exists a number which is their maximum&rsquo;. Giving this maximum the abstract name <tt>max(X,Y)</tt> yields the clause
 </p>
 <p class="p-el">
  maximum(X,Y,max(X,Y)):-number(X),number(Y)
 </p>
<div class="extract exercise" id="a_2.10">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.10</i>. Determine the Herbrand   universe of the following program:<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>length([],0).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length([X|Y],s(L)):-length(Y,L).<br></tt> (Hint: recall that <tt>[]</tt> is a constant, and   that <tt>[X|Y]</tt> is an alternative notation for the complex term <tt>.(X,Y)</tt> with   binary functor &lsquo; <tt>.</tt> &rsquo;!)
      </p>
     </div>
</div>
 <p class="answer">
  In the intended interpretation, <tt>s</tt> is restricted to numbers and &lsquo; <tt>.</tt> &rsquo; is restricted to lists; however, variables are untyped in clausal logic, and the two sets of terms may be mixed.&nbsp;Thus, the Herbrand universe&nbsp;will contain terms denoting numbers, such as
 </p>
 <p class="p-el">
  0
  <span class="AutoStyle25">
   ,
  </span>
  s(0)
  <span class="AutoStyle25">
   ,
  </span>
  s(s(0))
  <span class="AutoStyle25">
   ,
  </span>
  s(s(s(0)))
  <span class="AutoStyle25">
   , &hellip;
  </span>
 </p>
 <p class="tekst">
  and terms denoting lists of numbers, such as
 </p>
 <p class="p-el">
  []
  <span class="AutoStyle25">
   ,
  </span>
  [0]
  <span class="AutoStyle25">
   ,
  </span>
  [s(0),0]
  <span class="AutoStyle25">
   ,
  </span>
  [s(s(0)),s(0),0]
  <span class="AutoStyle25">
   , &hellip;
  </span>
 </p>
 <p class="tekst">
  but also &lsquo;strange&rsquo; terms like
 </p>
 <p class="p-el">
  [[[0]]]
  <span class="AutoStyle25">
   or
  </span>
  .(.(.(0,[]),[]),[])<br>
  [s(0)|0]
<span class="AutoStyle25">
   or
  </span>
  .(s(0),0)<br>
  [s([[]|0])]
</p>
 <p class="tekst">
  and so on.
 </p>
<div class="extract exercise" id="a_2.11">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.11</i>. If possible, unify the   following pairs of terms:<br>
       (<i>a</i>)&nbsp;&nbsp;&nbsp;&nbsp;<tt>plus(X,Y,s(Y))</tt> and <tt>plus(s(V),W,s(s(V)))</tt>;<br>
       (<i>b</i>)&nbsp;&nbsp;&nbsp;&nbsp;<tt>length([X|Y],s(0))</tt> and <tt>length([V],V)</tt>;<br>
       (<i>c</i>)&nbsp;&nbsp;&nbsp;&nbsp;<tt>larger(s(s(X)),X)</tt> and <tt>larger(V,s(V))</tt>.
      </p>
     </div>
</div>
 <p class="answer">
  (<i>a</i>) <tt>plus(s(V),s(V),s(s(V)))</tt>.
 </p>
 <p class="answer">
  (<i>b</i>) <tt>length([s(0)],s(0))</tt>.
 </p>
 <p class="answer">
  (<i>c</i>) Not unifiable.
 </p>
<div class="extract exercise" id="a_2.13">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.13.</i> Write a clause for the   statement &lsquo;somebody is innocent unless proven guilty&rsquo;, and give its intended   model (supposing that <tt>john</tt> is the only individual in the Herbrand universe).
      </p>
     </div>
</div>
 <p class="answer">
  The clause is
 </p>
 <p class="p-el">
  innocent(X):-not guilty(X)
 </p>
 <p class="tekst">
  with intended model { <tt>innocent(john)</tt> }.
 </p>
<div class="extract exercise" id="a_2.14">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 2.14</i>. Translate to clausal   logic:<br>
       (<i>a</i>)&nbsp;&nbsp;&nbsp;&nbsp;
<span class="AutoStyle09">
        &forall;
       </span>
       <tt>X</tt>
       <span class="AutoStyle09">
        &exist;
       </span>
       <tt>Y: mouse(X)</tt>
       <span class="AutoStyle09">
        &rarr;
       </span>
       <tt>tail_of(Y,X)</tt>;<br>
       (<i>b</i>)&nbsp;&nbsp;&nbsp;&nbsp;
<span class="AutoStyle09">
        &forall;
       </span>
       <tt>X</tt>
       <span class="AutoStyle09">
        &exist;
       </span>
       <tt>Y: loves(X,Y)</tt>
       <span class="AutoStyle09">
        &and;
       </span>
       <tt>(</tt>
       <span class="AutoStyle09">
        &forall;
       </span>
       <tt>Z: loves(Y,Z))</tt>;<br>
       (<i>c</i>)&nbsp;&nbsp;&nbsp;&nbsp;
<span class="AutoStyle09">
        &forall;
       </span>
       <tt>X</tt>
       <span class="AutoStyle09">
        &forall;
       </span>
       <tt>Y</tt>
       <span class="AutoStyle09">
        &exist;
       </span>
       <tt>Z:   number(X)</tt>
       <span class="AutoStyle09">
        &and;
       </span>
       <tt>number(Y)</tt>
       <span class="AutoStyle09">
        &rarr;
       </span>
       <tt>maximum(X,Y,Z)</tt>.
      </p>
     </div>
</div>
 <p class="answer">
  (<i>a</i>) This statement translates almost immediately into a clause, replacing the existential quantifier by a Skolem functor&nbsp;<tt>tail</tt>:
 </p>
 <p class="p-el AutoStyle83">
  tail_of(tail(X),X):-mouse(X)
 </p>
 <p class="answer">
  (<i>b</i>) This formula is already in conjunctive normal form, and each conjunct yields a separate clause. After replacing the existential quantifier by a Skolem functor <tt>person_loved_by</tt>, we obtain
 </p>
 <p class="p-el AutoStyle83">
  loves(X,person_loved_by(X)).<br>
  loves(person_loved_by(X),Z).
</p>
 <p class="tekst">
  Notice that the two clauses are &lsquo;linked&rsquo; by the Skolem functor.
 </p>
 <p class="sektie">
  (<i>c</i>) Here, the Skolem functor has two arguments:
 </p>
 <p class="p-el AutoStyle83">
  maximum(X,Y,max(X,Y)):-number(X),number(Y)
 </p>
 <p class="tekst">
  See also Exercise 2.9.
 </p>
 <h3 id="logic_programming_and_prolog_c">
  C.3&nbsp;&nbsp;Logic Programming and Prolog
 </h3>
<div class="extract exercise" id="a_3.2">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.2.</i> Draw the SLD-tree for   the following program:<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>list([]).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list([H|T]):-list(T).</tt><br>
and the query <tt>?-list(L)</tt>.
      </p>
     </div>
</div>
 <p class="answer">
  This is one of the simplest infinite SLD-trees:
 </p>
<div class="extract figure" id="a.4">
 <p class="figure">
  <img src="img/part_a/image008.svg" v:shapes="Picture_x0020_4" width="35%">
  </img>
 </p>
</div>
 <p class="tekst">
  The query succeeds infinitely often, producing the answers:
 </p>
 <p class="p-el">
  L = [];<br>
  L = [X1,X2];<br>
  L = [Y1,Y2,Y3];<br>
  L = [Z1,Z2,Z3,Z4];
</p>
 <p class="tekst">
  and so on. Note that reversing the order of the clauses means that Prolog gives no answer at all.
 </p>
<div class="extract exercise" id="a_3.3">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.3.</i> Draw the SLD-tree for   the query <tt>?-likes(A,B)</tt>, given the following program:<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;likes(peter,Y):-friendly(Y).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;likes(T,S):-student_of(S,T).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;student_of(maria,peter).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;student_of(paul,peter).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;friendly(maria).<br></tt> Add a cut in order to prune away one of the answers { <tt>A</tt>
       <span class="AutoStyle09">
        &rarr;
       </span>
       <tt>peter</tt>, <tt>B</tt>
       <span class="AutoStyle09">
        &rarr;
       </span>
       <tt>maria</tt> }, and indicate the   result in the SLD-tree. Can this be done without pruning away the third   answer?
      </p>
     </div>
</div>
 <p class="answer">
  This program produces three answers:
 </p>
 <p class="answer">
  &nbsp;
 </p>
<div class="extract figure" id="a.5">
 <p class="figure">
  <img src="img/part_a/image010.svg" v:shapes="Picture_x0020_5" width="35%">
  </img>
 </p>
</div>
 <p class="tekst">
  &nbsp;
 </p>
 <p class="tekst">
  &nbsp;
 </p>
 <p class="tekst">
  Adding a cut to the first clause (before or after <tt>friendly(Y)</tt>) will prune away two answers (left figure). Adding a cut to the second clause can be done in two places: placing it just before the literal <tt>student_of(S,T)</tt> has no effect, while placing it at the end will only prune the answer { <tt>A</tt>
  <span class="AutoStyle09">
   &rarr;
  </span>
  <tt>peter</tt>, <tt>B</tt>
  <span class="AutoStyle09">
   &rarr;
  </span>
  <tt>paul</tt> } (right figure).
 </p>
 <p class="sektie">
  &nbsp;
 </p>
<div class="extract figure" id="a.6">
 <p class="figure">
  <img src="img/part_a/image012.svg" v:shapes="Picture_x0020_6" width="35%">
  </img>
  <img src="img/part_a/image014.svg" v:shapes="Picture_x0020_7" width="35%">
  </img>
 </p>
</div>
 <p class="tekst">
  &nbsp;
 </p>
 <p class="tekst">
  If in addition the two <tt>student_of</tt> clauses are swapped, only the second answer { <tt>A</tt>
  <span class="AutoStyle09">
   &rarr;
  </span>
  <tt>peter</tt>, <tt>B</tt>
  <span class="AutoStyle09">
   &rarr;
  </span>
  <tt>maria</tt> } is pruned.
 </p>
<div class="extract exercise" id="a_3.5">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.5.</i> Given the program<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bachelor(X):-not(married(X)),man(X).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;man(fred).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;man(peter).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;married(fred).<br></tt> draw the SLD-trees for the queries <tt>?-bachelor(fred)</tt> and <tt>?‑bachelor(peter)</tt>.
      </p>
     </div>
</div>
<div class="extract figure" id="a.7">
 <p class="figure">
  <img src="img/part_a/image016.svg" v:shapes="Picture_x0020_8" width="70%">
  </img>
 </p>
</div>
<div class="extract exercise" id="a_3.6">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.6.</i> Change the first clause   to<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bachelor(X):-not(married(X)),man(X)<br></tt> and show that the modified program produces the right   answer, by drawing the SLD-tree for the query <tt>?-bachelor(X)</tt>.
      </p>
     </div>
</div>
<div class="extract figure" id="a.8">
 <p class="figure">
  <img src="img/part_a/image018.svg" v:shapes="Picture_x0020_9" width="70%">
  </img>
 </p>
</div>
<div class="extract exercise" id="a_3.7">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle84">
       <i>Exercise 3.7.</i> Given the   program<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>p:-q,r,s,!,t.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p:-q,r,u.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u.<br></tt> show that the query <tt>?-p</tt> succeeds, but that <tt>q</tt> and <tt>r</tt> are tried   twice.
      </p>
     </div>
</div>
<div class="extract figure" id="a.9">
 <p class="figure">
  <img src="img/part_a/image020.svg" v:shapes="Picture_x0020_10" width="35%">
  </img>
 </p>
</div>
<div class="extract exercise" id="a_3.8">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.8.</i> Given the equivalent   program with if-then-else<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>p:-q,r,if_s_then_t_else_u.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if_s_then_t_else_u:-s,!,t.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if_s_then_t_else_u:-u.<br>
        show</tt> that <tt>q</tt> and <tt>r</tt> are now tried only   once.
      </p>
     </div>
</div>
<div class="extract figure" id="a.10">
 <p class="figure">
  <img src="img/part_a/image022.svg" v:shapes="Picture_x0020_11" width="35%">
  </img>
 </p>
</div>
<div class="extract exercise" id="a_3.9">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.9.</i> Write a predicate <tt>zero(A,B,C,X)</tt> which, given the coefficients <i>a</i>, <i>b</i> and <i>c</i>, calculates both values of <i>x</i> for which <i>ax</i>
       <span class="AutoStyle46">
        2
       </span>
       + <i>bx</i> + <i>c</i> =0.
      </p>
     </div>
</div>
 <p class="pi-eerst">
  zero(A,B,C,X):-<br>
  X is (-B + sqrt(B*B - 4*A*C)) / 2*A.
</p>
 <p class="pi-laatst">
  zero(A,B,C,X):-<br>
  X is (-B - sqrt(B*B - 4*A*C)) / 2*A.
</p>
<div class="extract exercise" id="a_3.10">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.10.</i> Given the program<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>length([],0).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length([H|T],N):-length(T,M),N   is M+1.<br></tt> draw the proof tree for the query <tt>?-length([a,b,c],N)</tt>.
      </p>
     </div>
</div>
<div class="extract figure" id="a.11">
 <p class="figure">
  <img src="img/part_a/image024.svg" v:shapes="Picture_x0020_12" width="70%">
  </img>
 </p>
</div>
 <p class="tekst">
  Notice that the maximum number of literals in the resolvent is proportional to the depth of the recursion, which is typical for non-tail recursive predicates. When proofs are long, such programs will be quite inefficient.
 </p>
<div class="extract exercise" id="a_3.11">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.11.</i> Given the   program<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>length_acc(L,N):-length_acc(L,0,N).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length_acc([],N,N).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length_acc([H|T],N0,N):-N1   is N0+1,length_acc(T,N1,N).<br></tt> draw the proof tree for the query <tt>?-length_acc([a,b,c],N)</tt>.
      </p>
     </div>
</div>
 <p class="answer">
  In this program, the <tt>is</tt> literals are solved immediately after they are added to the resolvent:
 </p>
<div class="extract figure" id="a.12">
 <p class="figure">
  <img src="img/part_a/image026.svg" v:shapes="Picture_x0020_13" width="70%">
  </img>
 </p>
</div>
 <p class="tekst">
  Here, the length of the resolvent is independent of the level of recursion, which makes tail-recursive loops very similar to iterative loops with regard to memory requirements.
 </p>
<div class="extract exercise" id="a_3.13">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.13.</i> In the <tt>naive_reverse</tt> predicate, represent the reversed list by a difference list, use <tt>append_dl</tt> instead of <tt>append</tt>, and show that this results in the predicate <tt>reverse_dl</tt> by   unfolding the definition of <tt>append_dl</tt>.
      </p>
     </div>
</div>
 <p class="answer">
  The reversed lists are represented by difference lists as follows:
 </p>
 <p class="opsomming">
  &bull;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(partly) specified lists are extended with a variable representing the minus list, e.g. <tt>[]</tt> becomes <tt>R-R</tt>, and <tt>[H]</tt> becomes <tt>[H|Minus]-Minus</tt>;
 </p>
 <p class="opsomming">
  &bull;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a variable representing a list is replaced by two variables representing the plus and minus lists, e.g. <tt>R</tt> becomes <tt>RPlus-RMinus</tt>.
 </p>
 <p class="pi-eerst">
  reverse([],R-R).
 </p>
 <p class="pi-laatst AutoStyle85">
  reverse([H|T],RPlus-RMinus):-<br>
  reverse(T,R1Plus-R1Minus),<br>
  append_dl(R1Plus‑R1Minus,[H|Minus]‑Minus,RPlus‑RMinus).
</p>
 <p class="tekst">
  Unfolding the call to <tt>append_dl/3</tt> means that <tt>R1Plus</tt> should be unified with <tt>RPlus</tt>, <tt>R1Minus</tt> with <tt>[H|Minus]</tt>, and <tt>Minus</tt> with <tt>RMinus</tt>, which yields
 </p>
 <p class="pi-eerst">
  reverse([],R-R).
 </p>
 <p class="pi-laatst">
  reverse([H|T],RPlus-RMinus):-<br>
  reverse(T,RPlus-[H|RMinus]).
</p>
 <p class="tekst">
  Renaming the variables results in the same definition as <tt>reverse_dl/2</tt>.
 </p>
 <p class="sektie">
  This illustrates that the translation from simple lists to difference lists can (to a large extent) be automated.
 </p>
<div class="extract exercise" id="a_3.14">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.14.</i> Rewrite the program for <tt>rel</tt>, using <tt>=..</tt>
      </p>
     </div>
</div>
 <p class="pi-eerst">
  rel(R,[],[]).
 </p>
 <p class="pi-laatst">
  rel(R,[X|Xs],[Y|Ys]):-<br>
  Goal =.. [R,X,Y],<br>
  call(Goal),<br>
  rel(R,Xs,Ys).
</p>
 <p class="tekst">
  Note that, in contrast with the original program, this program conforms to the syntax of clausal logic: there are no variables in functor or literal positions.
 </p>
<div class="extract exercise" id="a_3.15">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.15.</i> Write a program which   sorts and removes duplicates from a list, using <tt>setof</tt>.
      </p>
     </div>
</div>
 <p class="answer">
  The basic idea is to use <tt>element/2</tt> to generate the elements of the list on backtracking, and to collect and sort them by means of <tt>setof/2</tt>.
 </p>
 <p class="pi-el">
  sort(List,SortedList):-<br>
  setof(X,element(X,List),SortedList).
</p>
 <p class="pi">
  element(X,[X|Ys]).
 </p>
 <p class="pi-laatst">
  element(X,[Y|Ys]):-<br>
  element(X,Ys).
</p>
<div class="extract exercise" id="a_3.18">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.18.</i> Implement a predicate <tt>permutation/2</tt>,   such that <tt>permutation(L,P)</tt> is true if <tt>P</tt> contains the same elements as the list <tt>L</tt> but (possibly) in a   different order, following these steps. (One auxiliary predicate is needed.)
      </p>
     </div>
</div>
 <p class="answer">
  As usual, we start with the declarative specification:
 </p>
 <p class="p-el">
  % permutation(L,P) &lt;- P contains the same elements as L<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(possibly in a different order)
</p>
 <p class="tekst">
  Taking the first argument as the recursion argument and the second as the output argument, we obtain the following skeleton:
 </p>
 <p class="pi-eerst">
  permutation([],[]).
 </p>
 <p class="pi-laatst">
  permutation([Head|Tail],?Permutation):-<br>
  /* do something with Head */<br>
  permutation(Tail,Permutation).
</p>
 <p class="tekst">
  Inserting <tt>Head</tt> somewhere in <tt>Permutation</tt> should yield <tt>?Permutation</tt>:
 </p>
 <p class="pi-eerst">
  permutation([],[]).
 </p>
 <p class="pi-laatst">
  permutation([Head|Tail],WholePermutation):-<br>
  insert_somewhere(Head,Permutation,WholePermutation),<br>
  permutation(Tail,Permutation).
</p>
 <p class="sektie">
  The predicate <tt>insert_somewhere/3</tt> can be obtained in the same way as the predicate <tt>insert/3</tt> (section 3.9) by ignoring the arithmetic conditions:
 </p>
 <p class="pi-eerst">
  insert_somewhere(X,[],[X]).
 </p>
 <p class="pi">
  insert_somewhere(X,[Head|Tail],[Head|Inserted]):-<br>
  insert_somewhere(X,Tail,Inserted).
</p>
 <p class="pi-laatst">
  insert_somewhere(X,[Head|Tail],[X,Head|Tail]).
 </p>
 <p class="tekst">
  This program, which is declaratively and procedurally correct, can be slightly improved by noting that the first and third clauses can be combined into a single base case:
 </p>
 <p class="pi-eerst">
  insert_somewhere(X,List,[X|List]).
 </p>
 <p class="pi-laatst">
  insert_somewhere(X,[Head|Tail],[Head|Inserted]):-<br>
  insert_somewhere(X,Tail,Inserted).
</p>
<div class="extract exercise" id="a_3.19">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 3.19.</i> Implement an   alternative sorting method by using the <tt>partition/4</tt> predicate.
      </p>
     </div>
</div>
 <p class="answer">
  This predicate implements the famous <i>quicksort</i>&nbsp;algorithm, which is one of the most efficient sorting algorithms:
 </p>
 <p class="pi-eerst">
  quicksort([],[]).
 </p>
 <p class="pi-laatst">
  quicksort([X|Xs],Sorted):-<br>
  partition(Xs,X,Littles,Bigs),<br>
  quicksort(Littles,SortedLittles),<br>
  quicksort(Bigs,SortedBigs),<br>
  append(SortedLittles,[X|SortedBigs],Sorted).
</p>
 <p class="tekst">
  The program can still be improved by employing difference lists.
 </p>
 <h3 id="representing_structured_knowledge_c">
  C.4&nbsp;&nbsp;Representing structured knowledge
 </h3>
 <p class="sektie1">
  The exercises in this chapter should not provide major difficulties.
 </p>
 <h3 id="searching_graphs_c">
  C.5&nbsp;&nbsp;Searching graphs
 </h3>
<div class="extract exercise" id="a_5.3">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 5.3.</i> Consider   the following program:<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother(peter,paul).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother(adrian,paul).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother(X,Y):-brother(Y,X).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother(X,Y):-brother(X,Z),brother(Z,Y).<br></tt> Compare and explain the behaviour of <tt>prove_bf/1</tt> and   Prolog on the query <tt>?‑brother(peter,adrian)</tt>. Can you re-order the clauses, such that Prolog succeeds?
      </p>
     </div>
</div>
 <p class="answer">
  Prolog will be trapped in an infinite loop, regardless of the order of the clauses. This is so because a refutation of <tt>?‑brother(peter,adrian)</tt> requires both recursive clauses, but whichever is found first will also be tried before the second one in all the other refutation steps. In contrast, <tt>prove_bf/1</tt> will be able to construct a refutation.
 </p>
<div class="extract exercise" id="a_5.5">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 5.5</i>. Give the models of the   program<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;married(X);bachelor(X):-man(X),adult(X).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has_wife(X):-married(X),man(X).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;man(paul).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adult(paul).</tt>
      </p>
     </div>
</div>
 <p class="answer">
  This program has four models (bachelors may have a wife, and married man may be bachelors):
 </p>
 <p class="p-el">
  <span class="AutoStyle25">
   {
  </span>
  man(paul)
  <span class="AutoStyle25">
   ,
  </span>
  adult(paul)
  <span class="AutoStyle25">
   ,
  </span>
  bachelor(paul)
  <span class="AutoStyle25">
   }<br>
   {
</span>
  man(paul)
  <span class="AutoStyle25">
   ,
  </span>
  adult(paul)
  <span class="AutoStyle25">
   ,
  </span>
  bachelor(paul)
  <span class="AutoStyle25">
   ,
  </span>
  has_wife(paul)
  <span class="AutoStyle25">
   }<br>
   {
</span>
  man(paul)
  <span class="AutoStyle25">
   ,
  </span>
  adult(paul)
  <span class="AutoStyle25">
   ,
  </span>
  married(paul)
  <span class="AutoStyle25">
   ,
  </span>
  has_wife(paul)
  <span class="AutoStyle25">
   }<br>
   {
</span>
  man(paul)
  <span class="AutoStyle25">
   ,
  </span>
  adult(paul)
  <span class="AutoStyle25">
   ,
  </span>
  married(paul)
  <span class="AutoStyle25">
   ,
  </span>
  bachelor(paul)
  <span class="AutoStyle25">
   ,<br>
   &nbsp;
</span>
  has_wife(paul)
  <span class="AutoStyle25">
   }
  </span>
 </p>
 <p class="tekst">
  The second and fourth models are non-minimal.
 </p>
<div class="extract exercise" id="a_5.6">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 5.6</i>. Are all minimal models   always constructed by <tt>model/1</tt>?
      </p>
     </div>
</div>
 <p class="sektie">
  Yes. The set of all Herbrand interpretations can be seen as a search space, in which the models are to be found. This search space is ordered by the subset relation. <tt>model/1</tt> starts from the empty interpretation, and repeatedly adds ground atoms until a model is constructed. Since one atom is added at a time, the procedure will never jump over a model. Since, on backtracking, all possible ways to satisfy a violated clause are considered, <tt>model/1</tt> performs a breadth-first search (which is complete).
 </p>
 <h3 id="informed_search_c">
  C.6&nbsp;&nbsp;Informed search
 </h3>
<div class="extract exercise" id="a_6.1">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 6.1.</i> Suppose the call <tt>children(Current,Children)</tt> results in an ordered list of children. Write a predicate <tt>merge/3</tt> which   directly merges this list with the current agenda.
      </p>
     </div>
</div>
 <p class="answer">
  This predicate is a little bit special because it requires <b>two</b> recursion arguments. Therefore, there are two recursive clauses and two base cases. Note that in the second clause the first argument is required to be a non-empty list. This is done to prevent the query <tt>?‑merge([],[],L)</tt> from succeeding twice.
 </p>
 <p class="pi-eerst">
  merge([],Agenda,Agenda).
 </p>
 <p class="pi">
  merge([Child|Children],[],[Child|Children]).% empty agenda
 </p>
 <p class="pi">
  merge([Child|Children],[Node|Agenda],[Child|NewAgenda]):-<br>
  eval(Child,ChildValue),<br>
  eval(Node,NodeValue),<br>
  ChildValue &lt; NodeValue,&nbsp;% Child is better than Node<br>
  merge(Children,[Node|Agenda],NewAgenda).
</p>
 <p class="pi-laatst">
  merge([Child|Children],[Node|Agenda],[Node|NewAgenda]):-<br>
  eval(Child,ChildValue),<br>
  eval(Node,NodeValue),<br>
  ChildValue &gt;= NodeValue,% Child not better than Node<br>
  merge([Child|Children],Agenda,NewAgenda).
</p>
<div class="extract exercise" id="a_6.4">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 6.4.</i> Find a position for   which the third heuristic is too pessimistic.
      </p>
     </div>
</div>
 <p class="answer">
  It is too pessimistic for the starting position (minimal cost 15, estimate 18).
 </p>
 <h3 id="reasoning_with_natural_language_c">
  C.7&nbsp;&nbsp;Reasoning with natural language
 </h3>
<div class="extract exercise" id="a_7.1">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 7.1</i>. Redraw the parse tree of   fig. 7.1 in the manner of an SLD proof tree, where &lsquo;resolvents&rsquo; are partially   parsed sentences such as<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>[the],[rapid],noun,verb_phrase</tt><br>
       and &lsquo;clauses&rsquo; are grammar rules.
</p>
     </div>
</div>
<div class="extract figure" id="a.13">
 <p class="figure">
  <img src="img/part_a/image028.svg" v:shapes="Picture_x0020_14" width="70%">
  </img>
 </p>
</div>
<div class="extract exercise" id="a_7.2">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 7.2</i>. Draw the search space   generated by the grammar in section 7.1 for a top-down parse, if grammar rules   are applied to sentences from left to right. Discuss the similarities and   differences with SLD-trees.
      </p>
     </div>
</div>
 <p class="answer">
  The search space is partly drawn below; the lower part, which contains all possible verb phrases, re-appears at three other nodes as indicated.
 </p>
<div class="extract figure" id="a.14">
 <p class="figure">
  <img src="img/part_a/image030.svg" v:shapes="Picture_x0020_15" width="70%">
  </img>
 </p>
</div>
 <p class="tekst">
  This search space is basically a propositional SLD-tree, with fully parsed sentences corresponding to success branches (failure branches occur only when for some syntactic category no grammar rules are specified).
 </p>
<div class="extract exercise" id="a_7.4">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 7.4</i>. Extend the following grammar rules with arguments expressing   their interpretation:<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verb_phrase&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt;   transitive_verb,proper_noun.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transitive_verb&nbsp;--&gt; [likes].</tt>
      </p>
     </div>
</div>
 <p class="answer">
  The transitive verb defines a binary mapping <tt>Y=&gt;X=&gt;L</tt>, which is applied to the meaning of the proper noun:
 </p>
 <p class="grammar">
  verb_phrase(M)&nbsp;--&gt; transitive_verb(Y=&gt;M),proper_noun(Y).<br>
  transitive_verb(Y=&gt;X=&gt;likes(X,Y))&nbsp;--&gt; [likes].
</p>
 <h3 id="reasoning_with_incomplete_information_c">
  C.8&nbsp;&nbsp;Reasoning with incomplete information
 </h3>
<div class="extract exercise" id="a_8.1">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 8.1</i>. Give the models of the   program<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bird(tweety).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ostrich(tweety).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flies(X):-bird(X),not   abnormal(X).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abnormal(X):-ostrich(X).<br></tt> (interpreting the general clause as the corresponding   indefinite clause). Which one is the intended model (see section 2.4)?
      </p>
     </div>
</div>
 <p class="answer">
  The models are
 </p>
 <p class="p-el">
  <span class="AutoStyle25">
   {
  </span>
  bird(tweety)
  <span class="AutoStyle25">
   ,
  </span>
  ostrich(tweety)
  <span class="AutoStyle25">
   ,
  </span>
  abnormal(tweety)
  <span class="AutoStyle25">
   }
  </span><br>
  <span class="AutoStyle25">
   {
  </span>
  bird(tweety)
  <span class="AutoStyle25">
   ,
  </span>
  ostrich(tweety)
  <span class="AutoStyle25">
   ,
  </span>
  abnormal(tweety)
  <span class="AutoStyle25">
   ,<br>
   &nbsp;
</span>
  flies(tweety)
  <span class="AutoStyle25">
   }
  </span>
 </p>
 <p class="tekst">
  i.e. Tweety, being an ostrich, is an abnormal bird which may or may not fly. The intended model is the first one, since we have no reason to assume that ostriches fly.
 </p>
<div class="extract exercise" id="a_8.2">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 8.2</i>. Give the models of the   program<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;likes(peter,S):-student_of(S,peter).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;student_of(paul,peter).</tt>
      </p>
     </div>
</div>
 <p class="answer">
  The Herbrand base of this program is
 </p>
 <p class="p-el AutoStyle30">
  <span class="AutoStyle25">
   {&nbsp;
  </span>
  likes(peter,peter)
  <span class="AutoStyle25">
   ,
  </span>
  likes(peter,paul)
  <span class="AutoStyle25">
   ,<br>
   </span>
  likes(paul,peter)
  <span class="AutoStyle25">
   ,
  </span>
  likes(paul,paul)
  <span class="AutoStyle25">
   ,<br>
   </span>
  student_of(peter,peter)
  <span class="AutoStyle25">
   ,
  </span>
  student_of(peter,paul)
  <span class="AutoStyle25">
   ,<br>
   </span>
  student_of(paul,peter)
  <span class="AutoStyle25">
   ,
  </span>
  student_of(paul,paul)
  <span class="AutoStyle25">
   }
  </span>
 </p>
 <p class="tekst">
  The atoms <tt>student_of(paul,peter)</tt> and <tt>likes(peter,paul)</tt> are <b>true</b> in every model. If the atom <tt>student_of(peter,peter)</tt> is <b>true</b>, then so is the atom <tt>likes(peter,peter)</tt> (three possibilities). Disregarding the other four atoms, we obtain the following models:
 </p>
 <p class="p-eerst">
  <span class="AutoStyle25">
   {&nbsp;
  </span>
  student_of(paul,peter)
  <span class="AutoStyle25">
   ,
  </span>
  likes(peter,paul)
  <span class="AutoStyle25">
   &nbsp;}
  </span>
 </p>
 <p class="programma">
  <span class="AutoStyle25">
   {&nbsp;
  </span>
  student_of(paul,peter)
  <span class="AutoStyle25">
   ,<br>
   &nbsp;&nbsp;&nbsp;
</span>
  likes(peter,paul)
  <span class="AutoStyle25">
   ,
  </span>
  likes(peter,peter)
  <span class="AutoStyle25">
   &nbsp;}
  </span>
 </p>
 <p class="p-laatst">
  <span class="AutoStyle25">
   {&nbsp;
  </span>
  student_of(paul,peter)
  <span class="AutoStyle25">
   ,
  </span>
  student_of(peter,peter)
  <span class="AutoStyle25">
   ,<br>
   &nbsp;&nbsp;&nbsp;
</span>
  likes(peter,paul)
  <span class="AutoStyle25">
   ,
  </span>
  likes(peter,peter)
  <span class="AutoStyle25">
   &nbsp;}
  </span>
 </p>
 <p class="tekst">
  Taking the four remaining atoms into account, we obtain 3*2
  <span class="AutoStyle56">
   4
  </span>
  =48 models. (See also Exercise 2.6.)
 </p>
<div class="extract exercise" id="a_8.3">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 8.3</i>. Apply Predicate   Completion to the program<br>
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wise(X):-not   teacher(X).<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;teacher(peter):-wise(peter).</tt>
      </p>
     </div>
</div>
 <p class="answer">
  The completion of this program is
 </p>
 <p class="pi-eerst">
  <span class="AutoStyle09">
   &forall;
  </span>
  X: wise(X)
  <span class="AutoStyle09">
   &harr;
  </span>
  &not;teacher(X)
 </p>
 <p class="pi-laatst">
  <span class="AutoStyle09">
   &forall;
  </span>
  X: teacher(X)
  <span class="AutoStyle09">
   &harr;
  </span>
  (X=peter
  <span class="AutoStyle09">
   &and;
  </span>
  wise(peter))
 </p>
 <p class="tekst">
  The first formula states that somebody is wise if and only if he is not a teacher; the second formula says that Peter is wise if and only if he is a teacher. Together, these two statements are inconsistent.
 </p>
 <h3 id="inductive_reasoning_c">
  C.9&nbsp;&nbsp;Inductive reasoning
 </h3>
<div class="extract exercise" id="a_9.3">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle82">
       <i>Exercise 9.3.</i> Determine the
       <span class="AutoStyle09">
        q
       </span>
       -LGG of the   following two clauses:<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>reverse([2,1],[3],[1,2,3]):-reverse([1],[2,3],[1,2,3])<br>
        &nbsp;&nbsp;&nbsp;reverse([a],[],[a]):-reverse([],[a],[a])</tt>
      </p>
     </div>
</div>
 <p class="p-el">
  reverse([H|T],A,[RH|RT]):-reverse(T,[H|A],[RH|RT])
 </p>
 <p class="tekst">
  This is the recursive clause in the version with accumulator&nbsp;of the <tt>reverse/3</tt>&nbsp;predicate (section 3.6), with one small difference: here, the third argument is required to be a non-empty list (which it always is). Notice that this clause is not strictly constrained, and cannot be inferred by the induction programs in sections 9.2 and 9.3 (see als Exercise 9.4).
 </p>
</div>
