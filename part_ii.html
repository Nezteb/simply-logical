---
layout: paper
part: Part II
---
<div class="WordSection1">
 <p class="romeinscijfer" id="reasoning_with_structured_knowledge">
  II
 </p>
 <div class="AutoStyle52">
  <h1 class="AutoStyle01" id="h_reasoning_with_structured_knowledge">
   Reasoning with<br>
   structured knowledge
</h1>
 </div>
 <p class="sektie1">
  A physical object is <i>structured</i> if it consists of several components having certain spatial relationships to each other. Likewise, knowledge is structured if its components have certain logical relationships. For instance, a description of the London underground system consists of a list of stations (the components) plus a list of connections between stations (the relationships). As can be seen in fig. 1.1 in Chapter 1, such structured knowledge has a convenient graphical representation, in which components are represented by points or <i>nodes</i>, and relationships are represented by lines or <i>arcs</i> between nodes. In mathematics, such graphical structures are called <i>graphs</i>.
 </p>
 <p class="sektie">
  A characteristic property of structured knowledge&nbsp;is the distinction that is made between <i>explicit</i> and <i>implicit</i> relationships. For instance, in the underground example the direct connections which exist between two stations are the explicit relationships. All other relationships (i.e. connections between stations that are further apart) are only implicitly represented, and must be reconstructed from the explicit relationships. Therefore, <i>reasoning</i> forms an integral part of any form of structured knowledge.
 </p>
 <p class="sektie">
  Other examples of structured knowledge, encountered in Part I, include Prolog terms, proof trees, and SLD-trees. Among these, SLD-trees constitute a special case, since they are not given <i>a priori</i> as part of the knowledge describing a certain Universe of Discourse, but are instead <i>derived</i> from problem specifications of the form &lsquo;given program <i>P</i>, find all answers to query <i>Q</i> &rsquo;. By means of SLD-trees, such problems are translated to problems of the form &lsquo;given SLD-tree <i>T</i>, find all paths from the root of the tree to the empty clause&rsquo;. Problems of the latter kind are called <i>search problems</i>, and the graph being searched is called a <i>search space.</i> Most problems in intelligent reasoning are search problems of one kind or the other.
 </p>
 <div class="extract figure" id="ii.1">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle20">
      <p class="med-figure AutoStyle07">
       <img src="img/part_ii/image002.svg" v:shapes="Picture_x0020_1" width="100%">
       </img><br>
       <br>
       (<i>a</i>) Starting position<br>
         <br>
         <br>
         <img src="img/part_ii/image004.svg" v:shapes="Picture_x0020_2" width="100%">
            </img><br>
            <br>
            (<i>b</i>) Intermediate position<br>
              <br>
              <br>
              <img src="img/part_ii/image006.svg" v:shapes="Picture_x0020_3" width="100%">
                 </img><br>
                 <br>
                 (<i>c</i>) Goal position
</p>
     </div>
     <p class="med-caption">
      <b>Figure   II.1.</b> The Towers of Hanoi.
     </p>
    </td>
   </tr>
  </table>
 </div>
 <p class="sektie">
  In principle, any given problem can be defined as a search problem. To this end, we must identify:
 </p>
 <p class="opsomming">
  (<i>i</i>)&nbsp;&nbsp;&nbsp;the nodes in the search space;
 </p>
 <p class="opsomming">
  (<i>ii</i>)&nbsp;&nbsp;the arcs between nodes;
 </p>
 <p class="opsomming">
  (<i>iii</i>)&nbsp;the starting node;
 </p>
 <p class="opsomming">
  (<i>iv</i>)&nbsp;the goal node.
 </p>
 <p class="tekst">
  For instance, when searching for an answer to a query by means of SLD-resolution, the nodes in the search space are resolvents, the arcs are resolution steps by means of a program clause, the starting node is the query, and the goal node is the empty clause. As another example, we consider the puzzle known as <i>The Towers of Hanoi</i>. This puzzle consists of three pegs and <i>n</i> disks of decreasing size. Initially, all the disks are on the left peg, such that no disk is placed on a smaller one. This rule is to be obeyed throughout the game. The goal is to move all the disks to the right peg by moving one disk at a time. This problem is easily reformulated as a search problem, where nodes are allowed positions, and arcs are moves of the upper disk on one peg to another. Starting node and goal node are as in fig. II.1.
 </p>
 <div class="extract infobox" id="an_analytic_solution_to_the_towers_of_hanoi">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle31">
      <p class="inter-title AutoStyle32">
       An analytic solution to the Towers of Hanoi
      </p>
      <p class="intermezzo AutoStyle32">
       In the case of the Towers of Hanoi, there is a   simple analytic solution based on the following observation: suppose we are   able to solve the problem for <i>n</i> &ndash;1   disks, then we can solve it for <i>n</i> disks also: move the upper <i>n</i> &ndash;1   disks from the left to the middle peg
       <span class="CustomFootnote">
        <a href="#_ftn1" name="_ftnref1" title="">
         <span class="MsoFootnoteReference">
          <span class="AutoStyle13">
           <span class="AutoStyle14">
            [12]
           </span>
          </span>
         </span>
        </a>
       </span>
       , move the remaining disk on the left peg to the right peg, and   move the <i>n</i> &ndash;1 disks from the   middle peg to the right peg. Since we are able to solve the problem for 0   disks, it follows by complete induction that we can solve the problem for any   number of disks. The inductive nature of this argument is nicely reflected in   the following recursive program:
      </p>
      <p align="left" class="intermezzo AutoStyle53">
       <tt>&nbsp;&nbsp;:-op(900,xfx,to).</tt>
      </p>
      <p align="left" class="intermezzo AutoStyle53">
       <tt>&nbsp;&nbsp;% hanoi(N,A,B,C,Moves) &lt;-Moves is the list of moves to<br>
        &nbsp;&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move   N disks from peg A to peg C,<br>
        &nbsp;&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using   peg B as intermediary peg</tt>
      </p>
      <p align="left" class="intermezzo AutoStyle53">
       <tt>&nbsp;&nbsp;hanoi(0,A,B,C,[]).</tt>
      </p>
      <p align="left" class="intermezzo AutoStyle54">
       <tt>&nbsp;&nbsp;hanoi(N,A,B,C,Moves):-<br>
        N1 is N-1,<br>
        hanoi(N1,A,C,B,Moves1),<br>
        hanoi(N1,B,A,C,Moves2),<br>
        append(Moves1,[A to C|Moves2],Moves).</tt>
      </p>
      <p class="intermezzo AutoStyle32">
       For instance, the query <tt>?-hanoi(3,left,middle,right,M)</tt> yields the answer
      </p>
      <p align="left" class="intermezzo AutoStyle55">
       <tt>&nbsp;&nbsp;M = [left to right, left to middle, right to middle,<br>
        left to right,<br>
        middle to left, middle to right, left to right ]</tt>
      </p>
      <p class="intermezzo AutoStyle33">
       The first three moves move the upper two disks   from the left to the middle peg, then the largest disk is moved to the right   peg, and again three moves are needed to move the two disks on the middle peg   to the right peg.
      </p>
     </div>
    </td>
   </tr>
  </table>
 </div>
 <p class="sektie">
  Since the number of allowed positions is 3 <i><span class="AutoStyle56">
    n
   </span></i>, the search space for the Towers of Hanoi grows exponentially with the number of disks. In practice, this means that the problem will be unsolvable for large <i>n</i>, no matter how efficient the search program, or how powerful the computer. <i>This is a common characteristic of search problems</i>. Search is a problem solving method which, although applicable to almost any problem, has considerable practical limitations. Therefore, search is only applied to problems for which no analytic solutions are known.
 </p>
 <p class="sektie">
  For many problems in intelligent reasoning such analytic solutions simply do not exist, and search is the best we can do. In Chapters 5 and 6, we will present and analyse various methods for searching graphs. Since graphs are not only important for search problems, but for all forms of structured knowledge, Chapter 4 is devoted to a discussion of various ways to represent structured knowledge in clausal logic.
 </p>
</div>
<b>
 <span class="AutoStyle02">
  <br clear="all"/>
 </span>
</b>
<div class="WordSection2">
 <p class="cijfer" id="representing_structured_knowledge">
  4
 </p>
 <h2 id="h_representing_structured_knowledge">
  Representing structured knowledge
 </h2>
 <p class="sektie1">
  In this chapter we will discuss various ways to represent structured knowledge in Prolog. The central notion is that of a <i>graph</i>, which is the mathematical abstraction of the graphical representation of structured knowledge. A graph consists of <i>nodes</i>, and <i>arcs</i> between nodes. Nodes are identified by their name, and arcs are identified by the pair of nodes they connect. By convention, arcs are taken to be <i>directed</i>, which means that an arc from <i>n</i>
  <span class="AutoStyle10">
   1
  </span>
  &nbsp;to <i>n</i>
  <span class="AutoStyle10">
   2
  </span>
  &nbsp;is not the same as an arc from <i>n</i>
  <span class="AutoStyle10">
   2
  </span>
  &nbsp;to <i>n</i>
  <span class="AutoStyle10">
   1
  </span>
  .Undirected arcs (as in the London Underground example&nbsp;of Chapter 1) can be viewed as consisting of two directed arcs, one in each direction. If an arc is directed from <i>n</i>
  <span class="AutoStyle10">
   1
  </span>
  &nbsp;to <i>n</i>
  <span class="AutoStyle10">
   2
  </span>
  , then <i>n</i>
  <span class="AutoStyle10">
   1
  </span>
  &nbsp;is called the <i>parent</i>&nbsp;of <i>n</i>
  <span class="AutoStyle10">
   2
  </span>
  , and <i>n</i>
  <span class="AutoStyle10">
   2
  </span>
  &nbsp;is called the <i>child</i>&nbsp;of <i>n</i>
  <span class="AutoStyle10">
   1
  </span>
  .
 </p>
 <p class="sektie">
  A <i>path</i> in a graph&nbsp;is a sequence of nodes, such that for each consecutive pair <i>n<span class="AutoStyle10">
    i
   </span></i>, <i>n<span class="AutoStyle10">
    j
   </span></i>&nbsp;in the sequence the graph contains an arc from <i>n<span class="AutoStyle10">
    i
   </span></i>&nbsp;to <i>n<span class="AutoStyle10">
    j
   </span></i>. If there is a path from <i>n<span class="AutoStyle10">
    k
   </span></i>&nbsp;to <i>n<span class="AutoStyle10">
    l
   </span></i>, then <i>n<span class="AutoStyle10">
    k
   </span></i>&nbsp;is called an <i>ancestor</i>&nbsp;of <i>n<span class="AutoStyle10">
    l
   </span></i>, and <i>n<span class="AutoStyle10">
    l
   </span></i>&nbsp;is called a <i>descendant</i>&nbsp;of <i>n<span class="AutoStyle10">
    k
   </span></i>. A <i>cycle</i>&nbsp;is a path from a node to itself. Obviously, when a path from <i>n<span class="AutoStyle10">
    i
   </span></i>&nbsp;to <i>n<span class="AutoStyle10">
    j
   </span></i>&nbsp;passes through a node which is also on a cycle, there are infinitely many different paths from <i>n<span class="AutoStyle10">
    i
   </span></i>&nbsp;to <i>n<span class="AutoStyle10">
    j
   </span></i>. Thus, a graph consisting of a limited number of nodes and arcs can generate infinite behaviour. This is something to keep in mind when searching such cyclic graphs!
 </p>
 <p class="sektie">
  A <i>tree</i>&nbsp;is a special kind of graph which contains a <i>root</i>&nbsp;such that there is a <b>unique</b> path from the root to any other node. From this it follows that for any two nodes in a tree, either there is no path between them, or there is exactly one. Thus, trees are necessarily non-cyclic or <i>acyclic</i>. A <i>leaf</i>&nbsp;is a node without children. Often, leaves are goal nodes in search spaces like SLD-trees. Strictly speaking, an SLD-tree&nbsp;is not a tree, because there might be several ways to construct the same resolvent. By convention, however, resolvents constructed in a different way are considered to be distinct nodes in the SLD-tree. Usually, trees are drawn upside down, with the root node at the top; arcs are implicitly understood to be directed from top to bottom. Note that, if <i>n</i> is the root of a tree, each of its children is the root of a <i>subtree</i>&nbsp;(fig. 4.1).
 </p>
 <div class="extract figure" id="4.1">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle20">
      <p class="med-figure AutoStyle07">
       <img src="img/part_ii/image000.svg" v:shapes="Picture_x0020_9" width="100%">
       </img>
      </p>
     </div>
     <p class="med-caption">
      <b>Figure   4.1.</b> A tree with two subtrees.
     </p>
    </td>
   </tr>
  </table>
 </div>
 <h3 id="trees_as_terms">
  4.1&nbsp;&nbsp;&nbsp;Trees as terms
 </h3>
 <p class="sektie1">
  Recall from section 1.3 that complex Prolog terms like
 </p>
 <p align="center" class="tekst AutoStyle57">
  <tt>route(tottenham_court_road,route(leicester_square,noroute))</tt>
 </p>
 <p class="tekst">
  can be viewed as a tree, with the functor <tt>route</tt> acting as the root of (sub)trees, and <tt>tottenham_court_road</tt>, <tt>leicester_square</tt>, and <tt>noroute</tt> as leaves (fig. 1.6). Conversely, trees can be represented by Prolog terms.
 </p>
<div class="extract exercise" id="4.1">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 4.1</i>. Draw the tree represented by the term <tt>1(2(4),3(5,6))</tt>.
  </p>
 </div>
</div>
 <p class="sektie">
  A tree is traversed by first visiting its root, and then recursively traversing all of its subtrees. A list of subtrees is obtained by decomposing the complex term&nbsp;by means of the <tt>=..</tt>&nbsp;predicate (see section 3.7):
 </p>
<div class="extract swish" id="4.1.1">
<pre class="source swish temp AutoStyle03" data-variant-id="group-4" id="swish.4.1.1" query-text="?- term_tree(n1(n2(n4,n5(n7),n6),n3(n8,n9(n10))),Root,Subtree). ?- term_tree(T,n1,[n2(n3),n4]).">
% term_tree(T,R,S) &lt;- term T represents a tree with root R and list of subtrees S
term_tree(Tree,Root,Subtrees):-
  Tree=..[Root|Subtrees].

% term_root(T,R) &lt;- R is the root of tree T
term_root(Tree,Root):-
  term_tree(Tree,Root,_S).

% term_subtree(T,S) &lt;- S is a subtree of tree T
term_subtree(Tree,Subtree):-
  term_tree(Tree,_R,S),
  member(Subtree,S).
</pre>
</div>
 <div class="extract infobox" id="data_abstraction">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle31">
      <p class="inter-title AutoStyle32">
       Data abstraction
      </p>
      <p class="intermezzo AutoStyle32">
       The principle of <i>data abstraction</i> prescribes to keep datastructures local to   specific predicates such as <tt>term_tree</tt>, <tt>term_root</tt> and <tt>term_subtree</tt>, and to access the datastructures only through these predicates.   The main advantage of this design principle is <i>modularity</i>: if we choose to change the representation of a tree,   we just have to modify these specific predicates, but the predicates which   call them need not be changed. In contrast, if we unfold&nbsp;<tt>term_tree</tt>, <tt>term_root</tt> and <tt>term_subtree</tt> into the definition of <tt>term_arc</tt>,<br>
       we get the following piece of code:
</p>
      <p align="left" class="intermezzo AutoStyle58">
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;term_arc(Tree,[Root,R]):-<br>
        Tree=..[Root|Subtrees].<br>
        element(Subtree,Subtrees),<br>
        Subtree=..[R|S].</tt>
      </p>
      <p align="left" class="intermezzo AutoStyle59">
       <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;term_arc(Tree,Arc):-<br>
        Tree=..[Root|Subtrees].<br>
        element(Subtree,Subtrees),<br>
        term_arc(Subtree,Arc).</tt>
      </p>
      <p class="intermezzo AutoStyle33">
       This program fragment is badly designed,   because <tt>term_arc</tt> explicitly mentions the way trees are represented by Prolog   terms. Consequently, if we change this representation, <tt>term_arc</tt> needs   to be changed as well. This illustrates that the design of good datastructures   is as important in Prolog<br>
       as it is in any other programming language.
</p>
     </div>
    </td>
   </tr>
  </table>
 </div>
 <p class="tekst">
  By means of these simple predicates, we can write a program for finding arcs and paths in a tree. Paths are represented as lists of nodes, and an arc&nbsp;is simply a path&nbsp;consisting of two nodes:
 </p>
<div class="extract swish" id="4.1.2">
<pre class="source swish inherit AutoStyle03" data-variant-id="group-4" id="swish.4.1.2" inherit-id="swish.4.1.1">
% term_arc(T,A) &lt;- T is a tree, and A is an arc in T
term_arc(Tree,[Root,SR]):- % Arc from Root to Subtree
  term_root(Tree,Root),
  term_subtree(Tree,Subtree),
  term_root(Subtree,SR).

term_arc(Tree,Arc):- % Arc in Subtree
  term_subtree(Tree,Subtree),
  term_arc(Subtree,Arc).

% term_path(T,P) &lt;- T is a tree, and P is a path in T
term_path(Tree,Arc):- % consisting of one arc
  term_arc(Tree,Arc).

term_path(Tree,[Node1,Node2|Nodes]):- % several arcs 
  term_arc(Tree,[Node1,Node2]),
  term_path(Tree,[Node2|Nodes]).
</pre>
</div>
<div class="extract exercise" id="4.2">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 4.2</i>. Give a term <tt>Tree</tt>, such that it contains the tree of exercise 4.1, and such that <tt>Path=[1,2,7,8]</tt> is an answer to the query<br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>?-term_path(Tree,Path)</tt>.
  </p>
 </div>
</div>
 <div class="extract figure" id="4.2">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle20">
      <p class="small-figure AutoStyle07">
       <img src="img/part_ii/image008.svg" v:shapes="Picture_x0020_5" width="100%">
       </img>
      </p>
     </div>
     <p class="small-caption">
      <b>Figure 4.2.</b> Which are the paths<br>
      through this tree?
</p>
    </td>
   </tr>
  </table>
 </div>
 <p class="sektie">
  Consider the tree in fig. 4.2. The following query lists all the paths in this tree:
 </p>
<div class="extract swish" id="4.1.1_2">
<pre class="query" id="query.4.1.1"><span class="swish query">?-term_path(n1(n2(n4,n5(n7),n6),n3(n8,n9(n10))),Path).</span></pre>
</div>
 <p class="query AutoStyle45">
  Path = [1,2];<br>
  Path = [1,3];<br>
  Path = [2,4];<br>
  Path = [2,5];<br>
  Path = [2,6];<br>
  Path = [5,7];<br>
  Path = [3,8];<br>
  Path = [3,9];<br>
  Path = [9,10];<br>
  Path = [1,2,4];<br>
  Path = [1,2,5];<br>
  Path = [1,2,6];<br>
  Path = [1,2,5,7];<br>
  Path = [1,3,8];<br>
  Path = [1,3,9];<br>
  Path = [1,3,9,10];<br>
  Path = [2,5,7];<br>
  Path = [3,9,10];<br>
  No more solutions
</p>
 <p class="MsoNormal">
  &nbsp;
 </p>
<div class="extract exercise" id="4.3">
     <div class="AutoStyle06">
      <p class="exercise AutoStyle60">
       <i>Exercise 4.3</i>. Explain   the order in which these paths are found.
      </p>
     </div>
 </div>
 <p class="sektie">
  It would be convenient to have a program for printing Prolog terms which represent trees in a tree-like way. The nicest way to do this is to print from the root down; however, this requires a rather elaborate program
  <span class="CustomFootnote">
   <a href="#_ftn2" name="_ftnref2" title="">
    <span class="MsoFootnoteReference">
     <span class="AutoStyle13">
      <span class="AutoStyle14">
       [13]
      </span>
     </span>
    </span>
   </a>
  </span>
  . A reasonable alternative is to print the tree rotated at 90 degrees, from the root to the right. A program to do this is given below.
 </p>
<div class="extract swish" id="4.1.3">
<pre class="source swish inherit AutoStyle03" data-variant-id="group-4" id="swish.4.1.3" inherit-id="swish.4.1.1" query-text="?- term_write(n1(n2(n4,n5(n7),n6),n3(n8,n9(n10)))).">
term_write(Tree):-
  term_write(0,Tree),nl.

% write a Tree at position Pos
term_write(Pos,Tree):-
  term_tree(Tree,Root,Subtrees),  % decompose Tree
  term_write_node(Pos,Pos2,Root), % write Root
  term_writes(Pos2,Subtrees).     % new position

% write a list of trees at position Pos
term_writes(Pos,[]).
term_writes(Pos,[Tree]):-!,       % no newline here
  term_write(Pos,Tree).
term_writes(Pos,[Tree|Subtrees]):-
  term_write(Pos,Tree),
  nl,tab(Pos),                    % skip to position Pos
  term_writes(Pos,Subtrees).

% write a Node from Begin to End
term_write_node(Begin,End,Node):-
  name(Node,L),length(L,N),       % N is length of Nodename
  End is Begin+10,
  N1 is End-Begin-N,              % N1 is length of line
  write_line(N1),
  write(Node).

% write a line of given length
write_line(0).
write_line(N):-
  N&gt;0,N1 is N-1,
  write('-'),
  write_line(N1).
</pre>
</div>
 <p class="tekst">
  <tt>name/2</tt>
  <span class="CustomFootnote">
   <a href="#_ftn3" name="_ftnref3" title="">
    <span class="MsoFootnoteReference">
     <span class="AutoStyle13">
      <span class="AutoStyle14">
       [14]
      </span>
     </span>
    </span>
   </a>
  </span>
  is a built-in predicate, converting an atom into a list of ASCII-codes. In combination with <tt>length/2</tt>, it is used to determine the number of characters in an atom. The query <tt>?-term_write(1(2(4,5(7),6),3(8,9(10))))</tt> displays the tree as follows:
 </p>
 <p class="p-el">
  ---------1---------2---------4<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---------5---------7<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---------6<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---------3---------8<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---------9--------10
</p>
 <h3 id="graphs_generated_by_a_predicate">
  4.2&nbsp;&nbsp;&nbsp;Graphs generated by a predicate
 </h3>
 <p class="sektie1">
  In the preceding section, a tree was represented by a Prolog term. This is convenient for relatively small trees such as proof trees, that are processed and passed around as a unit. However, for bigger trees it is a better idea not to represent them explicitly by a Prolog term, but implicitly by a set of ground facts, listing the arcs in the graph. An additional advantage of this representation is the possibility of representing graphs that are not trees.
 </p>
 <p class="sektie">
  As an example of this representation, the tree in fig. 4.2 would be represented by the following facts:
 </p>
 <p class="p-el">
  arc(1,2).<br>
  arc(1,3).<br>
  arc(2,4).<br>
  arc(2,5).<br>
  arc(2,6).<br>
  arc(5,7).<br>
  arc(3,8).<br>
  arc(3,9).<br>
  arc(9,10).
</p>
 <p class="tekst">
  The predicate for finding a path in a graph now needs a few minor adjustments: the graph is not passed on as an argument, and <tt>arc/2</tt> is used rather than <tt>term_arc/2</tt>:
 </p>
<div class="extract swish" id="4.2.1">
<pre class="source swish AutoStyle03" data-variant-id="group-4" id="swish.4.2.1" query-text="?- path([n1,Node2])." source-text-start="arc(n1,n2).
arc(n1,n3).
arc(n2,n4).
arc(n2,n5).
arc(n2,n6).
arc(n5,n7).
arc(n3,n8).
arc(n3,n9).
arc(n9,n10).
">
% path(P) &lt;- P is a path in the graph given by arc/2
path([Node1,Node2]):-
  arc(Node1,Node2).
path([Node1,Node2|Nodes]):-
  arc(Node1,Node2),
  path([Node2|Nodes]).
</pre>
</div>
<div class="extract exercise" id="4.4">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 4.4</i>. Draw the SLD-tree for the query <tt>?-path([1|Path])</tt>.
  </p>
 </div>
</div>
 <p class="sektie">
  <tt>path/2</tt> will generate paths between any two connected nodes. When searching a graph such as an SLD-tree, we are normally only interested in paths which start at a given node (for instance, the root of a tree), and end in a leaf. The following program will do the job. Note that this program differs from the previous one in that it allows for paths consisting of one node only.
 </p>
<div class="extract swish" id="4.2.2">
<pre class="source swish AutoStyle03" data-variant-id="group-4" id="swish.4.2.2" query-text="?- path_leaf(n1,Path). ?- path_leaf(Node,[N1,N2,N3])." source-text-start="arc(n1,n2).
arc(n1,n3).
arc(n2,n4).
arc(n2,n5).
arc(n2,n6).
arc(n5,n7).
arc(n3,n8).
arc(n3,n9).
arc(n9,n10).

">
% path_leaf(N,P) &lt;- P is a path starting at node N, ending 
%                      in a leaf in the graph given by arc/2
path_leaf(Leaf,[Leaf]):-
  leaf(Leaf).
path_leaf(Node1,[Node1|Nodes]):-
  arc(Node1,Node2),
  path_leaf(Node2,Nodes).

leaf(Leaf):-
  not(arc(Leaf,_SomeNode)).
</pre>
</div>
 <p class="tekst">
  The query <tt>?-path_leaf(1,Path)</tt> will lead to the following answers:
 </p>
 <p class="p-el">
  Path = [1,2,4];<br>
  Path = [1,2,5,7];<br>
  Path = [1,2,6];<br>
  Path = [1,3,8];<br>
  Path = [1,3,9,10];<br>
  No more solutions
</p>
<div class="extract exercise" id="4.5">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 4.5</i>. Draw the SLD-tree for this query.
  </p>
 </div>
</div>
 <p class="sektie">
  Notice the order in which the paths to the leafs are found &mdash; the longer path <tt>[1,2,5,7]</tt> is found before the shorter path <tt>[1,2,6]</tt>. This kind of search is called <i>depth-first search</i>, because the deepest unvisited nodes are preferred. In contrast, <i>breadth-first search</i>&nbsp;tries all nodes on a given level before going one level deeper; consequently, shortest paths are found first. Of course, the order in which nodes are visited can only be understood procedurally &mdash; logically speaking, there is nothing in the program which prescribes such an order. It is only because Prolog itself searches the SLD-tree in a depth-first fashion, that programs like the above perform depth-first search.
 </p>
 <p class="sektie1">
  In real life, graphs are often infinite. For instance, many SLD-trees are infinite, even for very simple programs such as (&lsquo;br&rsquo; abbreviates brother):
 </p>
 <p class="p-el">
  br(X,Y):-br(X,Z),br(Z,Y).<br>
  br(paul,peter).
</p>
<div class="extract exercise" id="4.6">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 4.6</i>. Sketch the SLD-tree for the query <tt>?-br(paul,B)</tt>.
  </p>
 </div>
</div>
 <p class="tekst">
  SLD-trees are graphs, with resolvents as nodes. Representing a resolvent by the list of its literals, we would need an infinite number of facts to represent SLD-trees, for instance:
 </p>
 <p class="p-el">
  arc([br(paul,B)],[br(paul,Z),br(Z,B)]).<br>
  arc([br(paul,B)],[]).<br>
  arc([br(paul,Z),br(Z,B)],[br(paul,Z1),br(Z1,Z),br(Z,B)]).<br>
  arc([br(paul,Z),br(Z,B)],[br(peter,B)]).<br>
  arc([br(paul,Z),br(Z,B)],[br(paul,paul)]).<br>
  ...<br>
  arc([br(peter,B)],[br(peter,Z),br(Z,B)]).<br>
  ...<br>
  arc([br(paul)],[br(paul,Z),br(Z,paul)]).<br>
  ...
</p>
 <p class="tekst">
  In such cases, it is a better idea to write a program which <b>generates</b> these facts. In other words, we need a logical definition of <tt>arc/2</tt>.
 </p>
 <p class="sektie">
  Now, <tt>arc(A,B)</tt> is true if <tt>A</tt> and <tt>B</tt> are lists of negative literals interpreted as resolvents, and one resolution step applied to <tt>A</tt> and a clause for <tt>br/2</tt> yields <tt>B</tt>. We can write this down by means of the predicate <tt>resolve/3</tt>, which performs one resolution step, and the two clauses for <tt>br/2</tt> in the appropriate representation. This gives the following program:
 </p>
<div class="extract swish" id="4.2.3">
<pre class="source swish AutoStyle03" data-variant-id="group-4" id="swish.4.2.3" query-text="?- arc([br(paul,B)],N).">
arc(A,B):- resolve(A,(br(X,Y):-[br(X,Z),br(Z,Y)]),B).
arc(A,B):- resolve(A,(br(paul,peter):-[]),B).

% resolve(G,C,NewG) &lt;- the goal G (a list of atoms)
%                          resolves with the clause C (body
%                          is a list) to yield the goal NewG
resolve([H1|T],(H2:-Body),B):-
  H1=H2,    % literal in goal unifies with head of clause
  append(Body,T,B).
resolve([H|T],Clause,[H|B]):-
  resolve(T,Clause,B).  % try next literal
</pre>
</div>
 <p class="MsoNormal">
  The query <tt>?-arc([br(paul,B)],N)</tt> results in the answers
 </p>
 <p class="p-el">
  B = Y<br>
  N = [br(paul,Z),br(Z,Y)];
</p>
 <p class="p-laatst">
  B = peter<br>
  N = []
</p>
 <p class="tekst">
  as expected.
 </p>
 <p class="sektie">
  Note that a query of the form <tt>?-arc(R,[])</tt> asks for a path from <tt>R</tt> to a success branch in the SLD-tree, thus simulating a query <tt>:-R</tt>. That is, the above program for <tt>arc/2</tt> is simply a meta-interpreter (with the object-level program hardwired in its clauses). In section 5.3, we encounter a similar meta-interpreter for full clausal logic.
 </p>
 <h3 id="inheritance_hierarchies">
  4.3&nbsp;&nbsp;&nbsp;Inheritance hierarchies
 </h3>
 <p class="sektie1">
  In the foregoing sections, we studied two kinds of graphs: trees represented by Prolog terms, and graphs generated by predicate definitions. In both cases, the main inference step is to search for a path satisfying certain conditions. In this section, we study a type of structured knowledge called an <i>inheritance hierarchy</i>, which differs from the previous cases in that it requires a more elaborate kind of reasoning. Basically, this is because a node in such a hierarchy is a more complex entity with various kinds of properties. Lower nodes in the hierarchy <i>inherit</i> properties from ancestor nodes, unless they are assigned a property of their own. Thus, reasoning about inheritance hierarchies not only requires searching for a path, but also collecting properties found along a path.
 </p>
 <div class="extract figure" id="4.3">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle05">
      <p class="figure">
       <img src="img/part_ii/image010.svg" v:shapes="Picture_x0020_6" width="100%">
       </img>
      </p>
     </div>
     <p class="Caption1">
      <b>Figure   4.3</b>. An inheritance hierarchy of musical   instruments. Nodes in the tree denote classes; at the bottom, instances for   each class are listed.
     </p>
    </td>
   </tr>
  </table>
 </div>
 <p class="sektie">
  Fig. 4.3 displays an inheritance hierarchy of a variety of musical instruments. The topmost node represents the <i>class</i>&nbsp;of all instruments in the Universe of Discourse, which has three <i>subclasses</i>: wind instruments, string instruments, and percussion instruments. In turn, wind instruments are divided into woodwinds and brass instruments, and so on. At the bottom of the figure, <i>instances</i> are listed for each most specific subclass. Thus, guitar, lute and harp are instances of the class &lsquo;plucked instruments&rsquo;, and thus also of the classes &lsquo;string instruments&rsquo; and &lsquo;instruments&rsquo;.
 </p>
 <p class="sektie">
  If we want to represent such hierarchies in Prolog, we have to choose a representation for instances and classes. By far the most natural choice is to represent an instance by a constant, and a class by a unary predicate. A class&ndash;superclass relation is then expressed by a clause, and an instance&ndash;class relation is expressed by a ground fact:
 </p>
<div class="extract swish" id="4.3.1">
<pre class="source swish temp AutoStyle03" data-variant-id="group-4" id="swish.4.3.1" query-text="?- instrument(X). ?- plucked(keyboard).">
% Classes
instrument(X):-wind(X).
instrument(X):-string(X).
instrument(X):-percussion(X).
wind(X):-woodwind(X).
wind(X):-brass(X).
string(X):-plucked(X).
string(X):-bowed(X).
string(X):-keyboard(X).
percussion(X):-tuned(X).
percussion(X):-untuned(X).

% Instances
woodwind(recorder).
woodwind(flute).
woodwind(oboe).
woodwind(saxophone).
brass(trumpet).
brass(trombone).
brass(horn).
plucked(guitar).
plucked(lute).
plucked(harp).
bowed(violin).
bowed(cello).
keyboard(harpsichord).
keyboard(piano).
tuned(triangle).
tuned(kettledrum).
untuned(cymbal).
untuned(snaredrum).
</pre>
</div>
 <p class="tekst">
  With these clauses, it is possible to ask questions about instances and (super)classes. For example, we can find out what instruments there are by means of the query
 </p>
 <p class="p-el">
  ?‑instrument(X).
 </p>
 <p class="sektie">
  As was remarked above, nodes (and instances) in an inheritance hierarchy can be assigned properties, where a <i>property</i>&nbsp;is an attribute&ndash;value pair. For instance, the material an instrument is made of can be an attribute, with possible values &lsquo;wood&rsquo; and &lsquo;metal&rsquo;.&nbsp;The statement &lsquo;saxophones are made of metal&rsquo; is represented by the ground fact
 </p>
 <p class="p-el">
  material(saxophone,metal)
 </p>
 <p class="tekst">
  The statement &lsquo;instances of the class of string instruments are made of wood&rsquo; is represented by the clause
 </p>
 <p class="pi-el">
  material(X,wood):-string(X).
 </p>
 <p class="tekst">
  Since <tt>string(piano)</tt> is a logical consequence of the previous clauses expressing the hierarchy, we can now prove <tt>material(piano,wood)</tt>. Thus, the chosen representation takes care of the inheritance of properties, as required.
 </p>
 <p class="sektie">
  In our musical Universe of Discourse, we consider three attributes: the <tt>function</tt> of an instrument (all instruments have a musical function), the <tt>material</tt> of an instrument (wood or metal), and the way the instrument produces sound, expressed by the attribute <tt>action</tt>:
 </p>
<div class="extract swish" id="4.3.2">
<pre class="source swish inherit AutoStyle03" data-variant-id="group-4" id="swish.4.3.2" inherit-id="swish.4.3.1" query-text="?- material(flute,M).">
function(X,musical):-instrument(X).

% Materials
material(flute,metal).
material(saxophone,metal).
material(X,wood):-woodwind(X).
material(X,metal):-brass(X).
material(X,wood):-string(X).
material(X,metal):-percussion(X).

% Actions
action(oboe,reed(double)).
action(saxophone,reed(single)).
action(harpsichord,plucked).
action(piano,hammered).
action(X,reed(lip)):-brass(X).
action(X,plucked):-plucked(X).
action(X,bowed):-bowed(X).
action(X,hammered):-percussion(X).
</pre>
</div>
 <p class="tekst">
  For instance, all brass instruments have lip-reeds, while some woodwinds have a double reed (oboes, for example) or a single reed (saxophones).
 </p>
 <p class="sektie">
  Note that there is a potential conflict in the above clauses: woodwinds are generally made of wood, but flutes and saxophones are made of metal. Thus, the query
 </p>
 <p class="p-el">
  ?-material(flute,M)
 </p>
 <p class="tekst">
  has two answers:
 </p>
 <p class="p-el">
  M = metal;<br>
  M = wood
</p>
 <p class="tekst">
  The order in which these answers are found is, of course, determined by the order of the clauses above. Since we put the ground facts listing properties of instances before the clauses listing properties assigned to classes (and the clauses pertaining to classes before those pertaining to superclasses), the answers are found by climbing the inheritance hierarchy from bottom to top, and the first property found is the desired one. It should be noted, however, that things are not always that simple. If more sophisticated <i>inheritance&nbsp;strategies</i> are needed, alternative representations, like the ones to be discussed later in this section, are to be preferred.
 </p>
 <p class="sektie">
  A typical thing one would like to know regarding an inheritance hierarchy is: what are the properties of a given instance? In principle, this requires a second-order query&nbsp;
 </p>
 <p class="p-el">
  ?-Attr(Inst,Value)
 </p>
 <p class="tekst">
  which is not allowed in Prolog if <tt>Attr</tt> is not instantiated. We can get around this by maintaining a list of all attributes, and constructing the appropriate goal for each attribute by means of the predicate <tt>get_value/3</tt>:
 </p>
<div class="extract swish" id="4.3.3">
<pre class="source swish inherit AutoStyle03" data-variant-id="group-4" id="swish.4.3.3" inherit-id="swish.4.3.1 swish.4.3.2" query-text="?- properties(saxophone,P).">
properties(Inst,Props):-
  attributes(Attrs),
  properties(Attrs,Inst,Props).
properties([],Inst,[]).
properties([Attr|Attrs],Inst,[Attr=Value|Props]):-
  get_value(Attr,Inst,Value),!,   % only first answer
  properties(Attrs,Inst,Props).

attributes([function,material,action]).

get_value(A,B,C):-
  Goal =.. [A,B,C],
  call(Goal).
</pre>
</div>
 <p class="tekst">
  For instance, the query <tt>?-properties(saxophone,P)</tt> yields the answer
 </p>
 <p class="p-el">
  P = [function=musical,material=metal,action=reed(single)]
 </p>
 <p class="tekst">
  Only the most specific property regarding material is found, because of the cut in the recursive clause of <tt>properties/3</tt>.
 </p>
 <p class="sektie">
  As indicated above, the representation of inheritance hierarchies by means of clauses only allows a relatively simple inheritance strategy. Moreover, since classes are represented by predicates, reasoning about classes becomes a second-order logical inference. For example, the question &lsquo;what are the subclasses of the class of instruments&rsquo; is not easily handled in the above representation. Both shortcomings can be alleviated if classes and attributes are represented by terms instead of predicates. In effect, this will result in a clearer separation of declarative knowledge describing the hierarchy, and procedural knowledge describing the inheritance strategy. This can be done in several ways; two possibilities are worked out below.
 </p>
 <p class="sektie1">
  The first idea is to represent the tree in fig. 4.3 according to the first method in section 4.2, i.e. by a set of ground facts listing the arcs in the tree. Thus, nodes (classes) are represented by constants, and arcs (class&ndash;superclass relations) are represented by means of the predicate <tt>isa/2</tt>:
 </p>
 <p class="oms-eerst">
  % Classes
 </p>
 <p class="programma">
  isa(wind,instrument).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isa(string,instrument).
 </p>
 <p class="programma">
  isa(percussion,instrument).&nbsp;&nbsp;isa(woodwind,wind).
 </p>
 <p class="programma">
  isa(brass,wind).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isa(plucked,string).
 </p>
 <p class="programma">
  isa(bowed,string).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isa(keyboard,string).
 </p>
 <p class="p-laatst">
  isa(tuned,percussion).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isa(untuned,percussion).
 </p>
 <div class="extract infobox" id="instance-class_vs_class-superclass">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle31">
      <p class="inter-title AutoStyle32">
       Instance&ndash;class vs.   class&ndash;superclass
      </p>
      <p class="intermezzo AutoStyle33">
       In this representation there appears to be no   difference between instance&ndash;class relations and class&ndash;superclass   relations. Indeed, we could have treated instances just as classes, and use   the <tt>isa/2</tt> predicate for both. However, this obscures the semantic difference   between instances and classes, which can lead to problems. For example,   instances of one class can be <i>composed</i> of instances of other classes (a bicycle is composed of two wheels and a   frame), but this is not true for classes<br>
       (the class of bicycles is not composed of the class of wheels<br>
       and the class of frames).
</p>
     </div>
    </td>
   </tr>
  </table>
 </div>
 <p class="tekst">
  Instances are listed by means of the predicate <tt>inst/2</tt>:
 </p>
 <p class="oms-eerst">
  % Instances
 </p>
 <p class="programma">
  inst(recorder,woodwind).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst(flute,woodwind).
 </p>
 <p class="programma">
  inst(oboe,woodwind).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst(saxophone,woodwind).
 </p>
 <p class="programma">
  inst(trumpet,brass).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst(trombone,brass).
 </p>
 <p class="programma">
  inst(horn,brass).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst(guitar,plucked).
 </p>
 <p class="programma">
  inst(lute,plucked).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst(harp,plucked).
 </p>
 <p class="programma">
  inst(violin,bowed).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst(cello,bowed).
 </p>
 <p class="programma">
  inst(harpsichord,keyboard).&nbsp;&nbsp;inst(piano,keyboard).
 </p>
 <p class="programma">
  inst(triangle,tuned).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst(kettledrum,tuned).
 </p>
 <p class="p-laatst">
  inst(cymbal,untuned).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inst(snaredrum,untuned).
 </p>
 <p class="sektie">
  The difference between inheritance&nbsp;hierarchies and ordinary graphs lies in the additional meaning assigned to classes and instances by means of properties. Therefore, a graph extended with properties is commonly called a <i>semantic network</i>. Properties are represented by means of the predicate <tt>prop/3</tt>:
 </p>
 <p class="oms-eerst">
  % Class properties
 </p>
 <p class="programma">
  prop(instrument,function,musical).
 </p>
 <p class="programma">
  prop(string,material,wood).
 </p>
 <p class="programma">
  prop(percussion,material,metal).
 </p>
 <p class="programma">
  prop(percussion,action,hammered).
 </p>
 <p class="programma">
  prop(woodwind,material,wood).
 </p>
 <p class="programma">
  prop(brass,material,metal).
 </p>
 <p class="programma">
  prop(brass,action,reed(lip)).
 </p>
 <p class="programma">
  prop(plucked,action,plucked).
 </p>
 <p class="p-laatst">
  prop(bowed,action,bowed).
 </p>
 <p class="oms">
  % Instance properties
 </p>
 <p class="programma">
  prop(flute,material,metal).
 </p>
 <p class="programma">
  prop(oboe,action,reed(double)).
 </p>
 <p class="programma">
  prop(saxophone,material,metal).
 </p>
 <p class="programma">
  prop(saxophone,action,reed(single)).
 </p>
 <p class="programma">
  prop(harpsichord,action,plucked).
 </p>
 <p class="p-laatst">
  prop(piano,action,hammered).
 </p>
 <p class="tekst">
  Since we will be using a more sophisticated inheritance strategy, the order of these facts is now immaterial.
 </p>
 <p class="sektie">
  The inheritance strategy is to collect the properties of instances before properties inherited from classes:
 </p>
 <p class="pi-el">
  properties_sn(Inst,Props):-<br>
  props(Inst,InstProps),&nbsp;&nbsp;&nbsp;% properties of instance<br>
  inst(Inst,Class),<br>
  inherit_sn(Class,InstProps,Props).% inherit the rest
</p>
 <p class="pi-laatst">
  props(IC,Props):-<br>
  findall(Attr=Value,prop(IC,Attr,Value),Props).
</p>
 <p class="tekst">
  In turn, inherited properties are collected from bottom to top in the hierarchy, so that specific properties are found before general properties:
 </p>
 <p class="pi-eerst">
  inherit_sn(top,Props,Props).
 </p>
 <p class="pi-laatst">
  inherit_sn(Class,SpecificProps,AllProps):-<br>
  props(Class,GeneralProps),% properties of this class<br>
  override(SpecificProps,GeneralProps,Props),<br>
  isa(Class,SuperClass),&nbsp;&nbsp;&nbsp;&nbsp;% climb hierarchy<br>
  inherit_sn(SuperClass,Props,AllProps).% inherit rest
</p>
 <p class="tekst">
  <tt>top</tt> refers to the root of the universal inheritance hierarchy, which should be added as the root of any sub-hierarchy:
 </p>
 <p class="p-el">
  isa(instrument,top).
 </p>
 <p class="sektie">
  The predicate <tt>override/3</tt> checks for every general property whether a more specific property has already been found. If so, we say that the specific property <i>overrides</i> the general property:
 </p>
<div class="extract swish" id="4.3.4">
<pre class="source swish AutoStyle03" data-variant-id="group-4" id="swish.4.3.4" query-text="?- properties_sn(saxophone,P)." source-text-start="% Classes
isa(instrument,top).
isa(wind,instrument).
isa(string,instrument).
isa(percussion,instrument).
isa(woodwind,wind).
isa(brass,wind).
isa(plucked,string).
isa(bowed,string).
isa(keyboard,string).
isa(tuned,percussion).
isa(untuned,percussion).

% Instances
inst(recorder,woodwind).
inst(flute,woodwind).
inst(oboe,woodwind).
inst(saxophone,woodwind).
inst(trumpet,brass).
inst(trombone,brass).
inst(horn,brass).
inst(guitar,plucked).
inst(lute,plucked).
inst(harp,plucked).
inst(violin,bowed).
inst(cello,bowed).
inst(harpsichord,keyboard).
inst(piano,keyboard).
inst(triangle,tuned).
inst(kettledrum,tuned).
inst(cymbal,untuned).
inst(snaredrum,untuned).

% Class properties
prop(instrument,function,musical).
prop(string,material,wood).
prop(percussion,material,metal).
prop(percussion,action,hammered).
prop(woodwind,material,wood).
prop(brass,material,metal).
prop(brass,action,reed(lip)).
prop(plucked,action,plucked).
prop(bowed,action,bowed).

% Instance properties
prop(flute,material,metal).
prop(oboe,action,reed(double)).
prop(saxophone,material,metal).
prop(saxophone,action,reed(single)).
prop(harpsichord,action,plucked).
prop(piano,action,hammered).


properties_sn(Inst,Props):-
  props(Inst,InstProps),    % properties of instance
  inst(Inst,Class),
  inherit_sn(Class,InstProps,Props). % inherit the rest

props(IC,Props):-
  findall(Attr=Value,prop(IC,Attr,Value),Props).

inherit_sn(top,Props,Props).
inherit_sn(Class,SpecificProps,AllProps):-
  props(Class,GeneralProps), % properties of this class
  override(SpecificProps,GeneralProps,Props),
  isa(Class,SuperClass),     % climb hierarchy
  inherit_sn(SuperClass,Props,AllProps). % inherit rest

">
override(Props,[],Props).
override(Specific,[Attr=_Val|General],Props):-
  member(Attr=_V,Specific),       % overriding
  override(Specific,General,Props).
override(Specific,[Attr=Val|General],[Attr=Val|Props]):-
  not(member(Attr=_V,Specific)),   % no overriding
  override(Specific,General,Props).
</pre>
</div>
 <p class="tekst">
  Again, the query <tt>?-properties_sn(saxophone,P)</tt> yields the answer
 </p>
 <p class="p-el">
  P = [function=musical,material=metal,action=reed(single)]
 </p>
 <p class="tekst">
  What we gained with this representation, however, is a declarative specification of the inheritance strategy, which is therefore also amenable to change. For instance, if the inheritance hierarchy is not a tree, a class could be a subclass of two or more other classes. In this case, different values for the same attribute could be inherited along different paths; this is called <i>multiple inheritance</i>. Such conflicts need to be resolved (or at least signalled) by the inheritance strategy.
 </p>
<div class="extract exercise" id="4.7">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 4.7</i>. Implement a multiple inheritance strategy.
  </p>
 </div>
</div>
 <p class="sektie1">
  A slightly different but related representation is obtained if we group all information about one class or instance together in a socalled <i>frame</i>. A frame representation is obtained from the semantic network representation by adding a list of properties to each arc in the network. Below, class frames are defined by the predicate <tt>class/3</tt>, and instance frames are defined by the predicate <tt>instance/3</tt>:
 </p>
 <p class="oms-eerst">
  % Classes
 </p>
 <p class="programma">
  class(instrument,top,[]).
 </p>
 <p class="programma">
  class(wind,instrument,[function=musical]).
 </p>
 <p class="programma">
  class(string,instrument,[material=wood]).
 </p>
 <p class="programma">
  class(percussion,instrument,[material=metal,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action=hammered]).
</p>
 <p class="programma">
  class(woodwind,wind,[material=wood]).
 </p>
 <p class="programma">
  class(brass,wind,[material=metal,action=reed(lip)]).
 </p>
 <p class="programma">
  class(plucked,string,[action=plucked]).
 </p>
 <p class="programma">
  class(bowed,string,[action=bowed]).
 </p>
 <p class="programma">
  class(keyboard,string,[]).
 </p>
 <p class="programma">
  class(tuned,percussion,[]).
 </p>
 <p class="p-laatst">
  class(untuned,percussion,[]).
 </p>
 <p class="programma">
  % Instances
 </p>
 <p class="programma">
  instance(recorder,woodwind,[]).
 </p>
 <p class="programma">
  instance(flute,woodwind,[material=metal]).
 </p>
 <p class="programma">
  instance(oboe,woodwind,[action=reed(double)]).
 </p>
 <p class="programma">
  instance(saxophone,woodwind,[material=metal,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action=reed(single)]).
</p>
 <p class="programma">
  /* etcetera... */
 </p>
 <p class="programma">
  instance(cymbal,untuned,[]).
 </p>
 <p class="p-laatst">
  instance(snaredrum,untuned,[]).
 </p>
 <p class="tekst">
  Inheritance is as easily implemented as in the semantic network representation:
 </p>
<div class="extract swish" id="4.3.5">
<pre class="source swish AutoStyle03" data-variant-id="group-2" id="swish.4.3.5" query-text="?- properties_fr(saxophone,P). ?- properties_fr(I,[function=musical,material=metal,A])." source-text-end="
override(Props,[],Props).
override(Specific,[Attr=_Val|General],Props):-
  member(Attr=_V,Specific),       % overriding
  override(Specific,General,Props).
override(Specific,[Attr=Val|General],[Attr=Val|Props]):-
  not(member(Attr=_V,Specific)),   % no overriding
  override(Specific,General,Props).
" source-text-start="% Classes
class(instrument,top,[]).
class(wind,instrument,[function=musical]).
class(string,instrument,[material=wood]).
class(percussion,instrument,[material=metal,action=hammered]).
class(woodwind,wind,[material=wood]).
class(brass,wind,[material=metal,action=reed(lip)]).
class(plucked,string,[action=plucked]).
class(bowed,string,[action=bowed]).
class(keyboard,string,[]).
class(tuned,percussion,[]).
class(untuned,percussion,[]).

% Instances
instance(recorder,woodwind,[]).
instance(flute,woodwind,[material=metal]).
instance(oboe,woodwind,[action=reed(double)]).
instance(saxophone,woodwind,[material=metal,action=reed(single)]).
instance(trumpet,brass,[]).
instance(trombone,brass,[]).
instance(horn,brass,[]).
instance(guitar,plucked,[]).
instance(lute,plucked,[]).
instance(harp,plucked,[]).
instance(violin,bowed,[]).
instance(cello,bowed,[]).
instance(harpsichord,keyboard,[action=plucked]).
instance(piano,keyboard,[action=hammered]).
instance(triangle,tuned,[]).
instance(kettledrum,tuned,[]).
instance(cymbal,untuned,[]).
instance(snaredrum,untuned,[]).

">
properties_fr(Inst,Props):-
  instance(Inst,Class,InstProps),       % instance properties
  inherit_fr(Class,InstProps,Props).    % inherit the rest

inherit_fr(top,Props,Props).
inherit_fr(Class,SpecificProps,AllProps):-
  class(Class,SuperClass,GeneralProps),         % this class
  override(SpecificProps,GeneralProps,Props),
  inherit_fr(SuperClass,Props,AllProps).        % inherit rest
</pre>
</div>
 <p class="tekst">
  Historically, semantic network and frame-based representations were proposed in quite different contexts. We see that their representation in Prolog is very similar.
 </p>
 <h3 id="further_reading_4">
  Further reading
 </h3>
 <p class="sektie1">
  An introduction to Knowledge Representation can be found in (Ringland &amp; Duce, 1989). (Brachman &amp; Levesque, 1985) is a collection of papers discussing various aspects of Knowledge Representation, such as the difference between isa-links and instance-of-links in semantic networks. Papers about inheritance hierarchies can be found in (Lenzerini <i>et al.</i>, 1991). LOGIN is an extension of Prolog in which inheritance is represented by terms rather than clauses (A&iuml;t-Kaci &amp; Nasr, 1986).
 </p>
 <p class="referenties">
  <span class="AutoStyle41">
   H. A&iuml;t-Kaci &amp; R. Nasr (
  </span>
  1986)
  <span class="AutoStyle41">
   ,
  </span>
  &lsquo;LOGIN: a logic programming language with built-in inheritance&rsquo;, <i>Journal of Logic Programming</i> <b>1986</b> (3): 185-215.
 </p>
 <p class="referenties">
  <span class="AutoStyle41">
   R.J. Brachman &amp; H.J. Levesque
  </span>
  (eds)
  <span class="AutoStyle41">
   (
  </span>
  1985)
  <span class="AutoStyle41">
   ,
  </span>
  <i>Readings in Knowledge Representation</i>, Morgan Kaufmann.
 </p>
 <p class="referenties">
  <span class="AutoStyle41">
   M. Lenzerini, D. Nardi &amp; M. Simi
  </span>
  (eds)
  <span class="AutoStyle41">
   (
  </span>
  1991)
  <span class="AutoStyle41">
   ,
  </span>
  <i>Inheritance Hierarchies in Knowledge Representation and Programming Languages</i>, John Wiley.
 </p>
 <p class="referenties">
  <span class="AutoStyle41">
   G.A. Ringland &amp; D.A. Duce
  </span>
  (eds)
  <span class="AutoStyle41">
   (
  </span>
  1989)
  <span class="AutoStyle41">
   ,
  </span>
  <i>Approaches to Knowledge Representation: an Introduction</i>, Research Studies Press.
 </p>
</div>
<b>
 <span class="AutoStyle02">
  <br clear="all"/>
 </span>
</b>
<div class="WordSection3">
 <p class="cijfer" id="searching_graphs">
  5
 </p>
 <h2 id="h_searching_graphs">
  Searching graphs
 </h2>
 <p class="sektie1">
  As explained earlier, a <i>search problem</i>&nbsp;is defined by a <i>search space</i>, which is a graph with one or more <i>starting nodes</i> and one or more <i>goal nodes</i>. Given a search space, a <i>solution</i> is a path from a starting node to a goal node . A <i>cost function</i>&nbsp;<i>c</i> assigns a number to each arc from <i>n</i>
  <span class="AutoStyle10">
   1
  </span>
  &nbsp;to <i>n</i>
  <span class="AutoStyle10">
   2
  </span>
  , specifying the <i>cost</i> of moving from <i>n</i>
  <span class="AutoStyle10">
   1
  </span>
  &nbsp;to <i>n</i>
  <span class="AutoStyle10">
   2
  </span>
  . The cost of a path is the sum of the costs of the arcs in the path. Given a search space and a cost function, an <i>optimal solution</i>&nbsp;is a solution with minimal cost. A trivial example of a cost function is <i>c</i> (<i>a</i>)=1 for each arc <i>a</i>, in which case the cost of a path equals the length of the path, and an optimal solution is a shortest path. For SLD proofs, such a cost function would measure the depth of the proof tree.
 </p>
 <p class="sektie">
  In this chapter, we will discuss and implement some basic techniques for finding solutions in search spaces. Their common denominator is that they are <i>exhaustive</i>: that is, in the worst case they will eventually visit every node in the search space along every possible path, before finding a solution. On the other hand, they differ with regard to:
 </p>
 <p class="opsomming AutoStyle61">
  &bull;&nbsp;<i>completeness</i>&nbsp;&mdash; will a solution always be found?
 </p>
 <p class="opsomming AutoStyle61">
  &bull;&nbsp;<i>optimality</i>&nbsp;&mdash; will shorter paths be found before longer ones?
 </p>
 <p class="opsomming AutoStyle61">
  &bull;&nbsp;<i>efficiency</i>&nbsp;&mdash; what are the runtime and memory requirements?
 </p>
 <p class="tekst">
  We start with a general discussion of the problem of search. Then, we will discuss the basic exhaustive search strategies: depth-first search, breadth-first search, and forward chaining.
 </p>
 <h3 id="a_general_search_procedure">
  5.1&nbsp;&nbsp;&nbsp;A general search procedure
 </h3>
 <p class="sektie1">
  Imagine a visit with a friend to the Staatsgalerie&nbsp;in Stuttgart. It is very crowded in this beautiful art museum, and while admiring theMondriaanworks you lose sight of each other. Having been through situations like this before, you had made the agreement that she would stay where she was, while you would go looking for her. What strategy would you employ?
 </p>
 <p class="sektie">
  First of all, to make sure that you don&rsquo;t miss any room, you have to visit them in some systematic way. You don&rsquo;t have a global map of the building, so you decide to never leave a room through the door through which you entered. Thinking about it, you recognise that this procedure won&rsquo;t fully work, because a room might have just one door: the one through which you entered. Assuming that there are still rooms not yet visited, you <b>have</b> to leave such a room through the same door through which you entered, and find a room you&rsquo;ve visited before, with a door not yet taken. Such a procedure, however, requires that, for each room you visit, you remember the door through which you entered the room (in order to go back to a room you&rsquo;ve been in before), and the doors you tried already (in order to try a remaining door).
 </p>
 <div class="extract figure" id="5.1">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle05">
      <p class="figure">
       <img src="img/part_ii/image012.svg" v:shapes="Picture_x0020_7" width="100%">
       </img>
      </p>
     </div>
     <p class="Caption1">
      <b>Figure 5.1.</b> Searching   for a friend.
     </p>
    </td>
   </tr>
  </table>
 </div>
 <p class="sektie">
  Luckily enough, you carry a piece of paper and a pencil with you, so you can stick little papers saying &lsquo;entrance&rsquo; or &lsquo;exit&rsquo; on the appropriate doors. However, the amount of paper you have is limited, so a better idea is to mark the doors <i>not yet</i> tried, and to remove the paper when you try a door, so that you can use the paper again. By reusing those pieces of paper that become obsolete, you minimise the amount of paper needed. Similarly, if you return to a room in which there are no remaining doors, you will never return to that room, so you might want to remove the paper saying &lsquo;entrance&rsquo; as well. On the other hand, leaving one paper might be a good idea, just in case you return to the room later via a &lsquo;circular&rsquo; route; you are then able to see that you already tried all the doors in that room.
 </p>
 <p class="sektie">
  So you decide to employ the following procedure:
 </p>
 <p class="opsomming AutoStyle50">
  1.&nbsp;&nbsp;&nbsp;mark every door in the starting room as &lsquo;exit&rsquo;;
 </p>
 <p class="opsomming">
  2.&nbsp;&nbsp;&nbsp;examine the current room;
 </p>
 <p class="opsomming">
  3.&nbsp;&nbsp;&nbsp;if you find your friend, stop;
 </p>
 <p class="opsomming">
  4.&nbsp;&nbsp;&nbsp;otherwise, if there are any doors marked &lsquo;exit&rsquo; in the room,
 </p>
 <p class="opsomming AutoStyle62">
  4a.&nbsp;&nbsp;choose one of them;
 </p>
 <p class="opsomming AutoStyle62">
  4b.&nbsp;&nbsp;remove the mark &lsquo;exit&rsquo;;
 </p>
 <p class="opsomming AutoStyle62">
  4c.&nbsp;&nbsp;go through it;
 </p>
 <p class="opsomming AutoStyle62">
  4d.&nbsp;&nbsp;if one of the doors in this room is already marked &lsquo;entrance&rsquo;, go back to the previous room, and go to step 4;
 </p>
 <p class="opsomming AutoStyle62">
  4d.&nbsp;&nbsp;otherwise, mark the door you just came through as &lsquo;entrance&rsquo;;
 </p>
 <p class="opsomming AutoStyle62">
  4e.&nbsp;&nbsp;mark all other doors as &lsquo;exit&rsquo;;
 </p>
 <p class="opsomming AutoStyle62">
  4f.&nbsp;&nbsp;go to step 2;
 </p>
 <p class="opsomming AutoStyle45">
  5.&nbsp;&nbsp;&nbsp;otherwise, take the door marked &lsquo;entrance&rsquo;, and go to step 4.
 </p>
 <div class="extract figure" id="5.2">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle05">
      <p class="figure">
       <img src="img/part_ii/image014.svg" v:shapes="Picture_x0020_8" width="45%">
       </img>
      </p>
     </div>
     <p class="Caption1">
      <b>Figure 5.2.</b> You find her   by systematically searching the rooms, backtracking when all the rooms   reachable from the room you&rsquo;re in<br>
      have been visited already (thin lines).
</p>
    </td>
   </tr>
  </table>
 </div>
 <p class="tekst">
  Steps 1-3 are obvious enough. In step 4, you check whether there are any untried doors left; if not, you have to go back to a previously visited room, and do the same there (step 5). This process of reconsidering previous decisions is called <i>backtracking</i>. It is an essential step in any exhaustive search procedure. If there are any alternatives left, you have to check whether you have been there already via some other route (step 4d). This step is called <i>loop detection</i>, and is only needed for cyclic&nbsp;search spaces. If you omit this step in such cases, you risk walking in circles forever. If you are in a yet unvisited room, you do some bookkeeping and proceed in the same way.
 </p>
 <p class="sektie">
  How does this search procedure work in practice? Suppose you are in the
  <span class="AutoStyle12">
   Mir&oacute;
  </span>
  room (fig. 5.1). You decide to try the doors in that room in a clockwise order. You first check the
  <span class="AutoStyle12">
   L&eacute;ger
  </span>
  room, then the
  <span class="AutoStyle12">
   Kupka
  </span>
  room, and finally the
  <span class="AutoStyle12">
   Kandinsky
  </span>
  room. When you enter the
  <span class="AutoStyle12">
   L&eacute;ger
  </span>
  room again from
  <span class="AutoStyle12">
   Kandinsky
  </span>
  , you realise that you&rsquo;ve been there before, because there&rsquo;s a door marked &lsquo;entrance&rsquo;. So you backtrack to
  <span class="AutoStyle12">
   L&eacute;ger
  </span>
  (because there are no alternatives left in
  <span class="AutoStyle12">
   Kandinsky
  </span>
  and
  <span class="AutoStyle12">
   Kupka
  </span>
  ), and try the next door. This one leads you straight to
  <span class="AutoStyle12">
   Kandinsky
  </span>
  again, and your little papers remind you that you have been there already. You backtrack again to
  <span class="AutoStyle12">
   L&eacute;ger
  </span>
  , and try the
  <span class="AutoStyle12">
   Matisse
  </span>
  room. From there,
  <span class="AutoStyle12">
   Klee
  </span>
  is a dead end, so you backtrack and finally find your friend still admiring the Mondriaan paintings! The route you walked is shown in fig. 5.2, (thin lines denote backtracking).
 </p>
 <p class="sektie">
  In a computer implementation of such a search procedure, you don&rsquo;t walk from room to room. Instead of marking nodes and returning to them later, the search program stores a description of those nodes in memory. In the above example, the number of marks needed corresponds to the amount of memory required during search, and just as marks can be used several times, memory space can be reclaimed once all the children of a node have been put on the list. This list of nodes to be tried next is called the <i>agenda</i>; this is an important concept, which can be used to describe any backtracking search procedure. Such a general-purpose agenda-based search algorithm operates as follows (for simplicity, we have omitted loop detection):
 </p>
 <p class="opsomming AutoStyle50">
  1.&nbsp;&nbsp;&nbsp;take the next node from the agenda;
 </p>
 <p class="opsomming">
  2.&nbsp;&nbsp;&nbsp;if it is a goal node, stop;
 </p>
 <p class="opsomming">
  3.&nbsp;&nbsp;&nbsp;otherwise,
 </p>
 <p class="opsomming AutoStyle62">
  3a.&nbsp;&nbsp;generate its children;
 </p>
 <p class="opsomming AutoStyle62">
  3b.&nbsp;&nbsp;put them on the agenda;
 </p>
 <p class="opsomming AutoStyle63">
  3c.&nbsp;&nbsp;go to step 1.
 </p>
 <p class="tekst">
  This procedure can be almost directly translated into a Prolog program:
 </p>
 <p class="oms-eerst">
  % search(Agenda,Goal) &lt;- Goal is a goal node, and a<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descendant of one of the nodes<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on the Agenda
</p>
 <p class="pi">
  search(Agenda,Goal):-<br>
  next(Agenda,Goal,Rest),<br>
  goal(Goal).
</p>
 <p class="pi-laatst">
  search(Agenda,Goal):-<br>
  next(Agenda,Current,Rest),<br>
  children(Current,Children),<br>
  add(Children,Rest,NewAgenda),<br>
  search(NewAgenda,Goal).
</p>
 <p class="tekst">
  In this program, we have abstracted from the way the agenda is represented. Furthermore, as remarked above, by specifying the order in which nodes are added to and removed from the agenda, we obtain specific search strategies. In the Staatsgalerie example, doors marked most recently are tried first. In other words, the agenda is a <i>last in&ndash;first out</i>&nbsp;datastructure, or a <i>stack</i>. In this example, it seems the most reasonable approach, because it minimises the amount of walking needed to backtrack to another room. The result is a <i>depth-first</i> search&nbsp;procedure, moving away as quickly as possible from the initial room, only coming closer again when backtracking.
 </p>
 <p class="sektie">
  On the other hand, the shortest path between your initial position and your friend is
  <span class="AutoStyle12">
   Mir&oacute;
  </span>
  -
  <span class="AutoStyle12">
   Mondriaan
  </span>
  , while you finally reach your friend along the path
  <span class="AutoStyle12">
   Mir&oacute;
  </span>
  -
  <span class="AutoStyle12">
   L&eacute;ger
  </span>
  -
  <span class="AutoStyle12">
   Matisse
  </span>
  -
  <span class="AutoStyle12">
   Mondriaan
  </span>
  <span class="CustomFootnote">
   <a href="#_ftn4" name="_ftnref4" title="">
    <span class="MsoFootnoteReference">
     <span class="AutoStyle13">
      <span class="AutoStyle14">
       [15]
      </span>
     </span>
    </span>
   </a>
  </span>
  . You would have found your friend sooner if you would have examined all rooms next to
  <span class="AutoStyle12">
   Mir&oacute;
  </span>
  first. But suppose your friend was two rooms away, e.g. in the
  <span class="AutoStyle12">
   Matisse
  </span>
  room? Well, in that case you would have gone to the rooms next to
  <span class="AutoStyle12">
   Mir&oacute;
  </span>
  (
  <span class="AutoStyle12">
   L&eacute;ger
  </span>
  and
  <span class="AutoStyle12">
   Mondriaan
  </span>
  ), and then to all rooms next to those (
  <span class="AutoStyle12">
   Kupka
  </span>
  ,
  <span class="AutoStyle12">
   Kandinsky
  </span>
  and
  <span class="AutoStyle12">
   Matisse
  </span>
  ). That is, doors marked most recently are tried last: a <i>first in&ndash;first out</i>&nbsp;strategy, implemented by a datastructure called a <i>queue</i>. Thus you would have found your friend along one of the two shortest paths (
  <span class="AutoStyle12">
   Mir&oacute;
  </span>
  -
  <span class="AutoStyle12">
   L&eacute;ger
  </span>
  -
  <span class="AutoStyle12">
   Matisse
  </span>
  ). This second method is an example of <i>breadth-first</i> search.
 </p>
 <p class="sektie">
  Finally, a third approach called <i>best-first</i> search&nbsp;orders the doors to be tried next according to some criterion called a <i>heuristic</i>. For instance, suppose you saw your friend last in the
  <span class="AutoStyle12">
   Mondriaan
  </span>
  room. In this case it would be wise to overrule the default clockwise ordering, and to try
  <span class="AutoStyle12">
   Mondriaan
  </span>
  before
  <span class="AutoStyle12">
   L&eacute;ger
  </span>
  . Consequently, you would have found your friend along the path
  <span class="AutoStyle12">
   Mir&oacute;
  </span>
  -
  <span class="AutoStyle12">
   Mondriaan
  </span>
  -
  <span class="AutoStyle12">
   Matisse
  </span>
  . In the following sections, we will take a closer look at depth-first and breadth-first search. The use of heuristics will be studied in Chapter 6.
 </p>
 <h3 id="depth_first_search">
  5.2&nbsp;&nbsp;&nbsp;Depth-first search
 </h3>
 <p class="sektie1">
  We obtain a depth-first search&nbsp;strategy if the agenda is implemented as a last in&ndash;first out&nbsp;datastructure. The obvious way to do this in Prolog is to represent the agenda by a list of nodes, and to add and remove nodes from the front of the list:
 </p>
 <p class="pi-eerst">
  % depth-first search
 </p>
 <p class="pi">
  search_df([Goal|Rest],Goal):-<br>
  goal(Goal).
</p>
 <p class="pi-laatst">
  search_df([Current|Rest],Goal):-<br>
  children(Current,Children),<br>
  append(Children,Rest,NewAgenda),<br>
  search_df(NewAgenda,Goal).
</p>

 <p class="tekst">
  The <tt>children/2</tt> predicate finds all children of a given node. If arcs in the search space are defined as before by the <tt>arc/2</tt> predicate, we could define <tt>children/2</tt> as
 </p>
 <p class="pi-el">
  children(Node,Children):-<br>
  findall(C,arc(Node,C),Children).
</p>
 <p class="tekst">
  In this way, all children of the current node are generated and stored on the agenda before examining the next node.
 </p>


<div class="extract swish" id="search_df">
<pre class="source swish AutoStyle03" data-variant-id="group-1" id="search_df" query-text="?-search_df([[a,d,a,m]],Goal).">
% an example of depth-first search
search_df([Goal|Rest],Goal):-
	goal(Goal).
search_df([Current|Rest],Goal):-
	children(Current,Children),
	append(Children,Rest,NewAgenda),
	search_df(NewAgenda,Goal).

children(Node,Children):-
	findall(C,arc(Node,C),Children).

% nodes are lists of letters
arc(T,[H|T]):-
	length(T,N),N<11,
	member(H,[a,d,i,m]).

% find palindromes
goal(L):-
    reverse(L,L).
</pre>
</div>


 <p class="sektie">
  This depth-first search program can be refined in several ways, of which we will consider two: returning a path to the goal, and loop detection. In the above implementation, it is impossible to return a path if we discover a goal node on the agenda, because we do not know how that goal node was reached. Instead of putting a single node on the agenda, we will store a complete path to that node. This is simply accomplished by changing the <tt>children/2</tt> predicate as follows:
 </p>
 <p class="pi-el">
  children([Node|Path],Children):-<br>
  findall([C,Node|Path],arc(Node,C),Children).
</p>
 <p class="tekst">
  Of course, the <tt>goal/1</tt> predicate must be changed accordingly, because its argument is now a path instead of a single node. A query now takes the form
 </p>
 <p class="pi-el">
  ?-search_df([[InitialNode]],PathToGoal).
 </p>
 <p class="sektie">
  The second refinement concerns loop detection. In order to check whether a node has been investigated before, we must maintain a list of visited nodes. We only add nodes to the agenda which do not already occur on this list (or on the agenda):
 </p>
 <p class="pi-eerst">
  % depth-first search with loop detection
 </p>
 <p class="pi">
  search_df_loop([Goal|Rest],Visited,Goal):-<br>
  goal(Goal).
</p>
 <p class="pi-laatst">
  search_df_loop([Current|Rest],Visited,Goal):-<br>
  children(Current,Children),<br>
  add_df(Children,Rest,Visited,NewAgenda),<br>
  search_df_loop(NewAgenda,[Current|Visited],Goal).
</p>
 <p class="pi">
  add_df([],Agenda,Visited,Agenda).
 </p>
 <p class="pi">
  add_df([Child|Rest],OldAgenda,Visited,[Child|NewAgenda]):-<br>
  not element(Child,OldAgenda),<br>
  not element(Child,Visited),<br>
  add_df(Rest,OldAgenda,Visited,NewAgenda).
</p>
 <p class="pi">
  add_df([Child|Rest],OldAgenda,Visited,NewAgenda):-<br>
  element(Child,OldAgenda),<br>
  add_df(Rest,OldAgenda,Visited,NewAgenda).
</p>
 <p class="pi-laatst">
  add_df([Child|Rest],OldAgenda,Visited,NewAgenda):-<br>
  element(Child,Visited),<br>
  add_df(Rest,OldAgenda,Visited,NewAgenda).
</p>
 <p class="sektie">
  Note that the combination of loop detection and path construction allows the following optimisation: instead of maintaining complete paths to a node on the agenda and the list of visited nodes, we only store a node together with its parent. Once we encounter a goal, all its parents are on the list of visited nodes, which allows us to reconstruct the path.
 </p>
<div class="extract exercise" id="5.1">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 5.1.</i> Modify the predicate <tt>search_df_loop/3</tt> such that it reconstructs the path to a goal in this way.
  </p>
 </div>
</div>
 <p class="sektie">
  We now analyse depth-first search with respect to completeness, optimality and efficiency. A search strategy is <i>complete</i>&nbsp;if it is guaranteed to find every goal. Obviously, any exhaustive strategy is complete for finite search spaces. However, in an infinite search space depth-first search might get trapped in an infinite branch before having found all the solutions. For instance, reconsider the infinite SLD-tree&nbsp;in fig. 3.2. A left-to-right depth-first search strategy would dive deeper and deeper into the tree, taking the left branch at every node, and never find the goals in the branches to the right. So, <i>depth-first search&nbsp;is, in general, incomplete</i>. Since Prolog itself employs depth-first search, Prolog&nbsp;is also incomplete. Often, however, the incompleteness of Prolog can be avoided by reordering the clauses such that goals are found before infinite branches (for instance, by putting the recursive clause last), and to cut away the infinite parts of the search space.
 </p>
 <p class="sektie">
  If there is no cost function, a search strategy is optimal if it is guaranteed to reach any goal along the shortest path possible.&nbsp;The Staatsgalerie example&nbsp;already showed that this is not true for depth-first search: you found your friend but, while she was in a room next to your initial position, you finally reached that room through two other rooms. Thus, <i>depth-first search does not always find a shortest solution path</i>.&nbsp;Finally, we can estimate the memory requirements for depth-first search&nbsp;as follows. Suppose we are searching a tree in which each node has, on the average, <i>B</i> children. The number <i>B</i> is known as the <i>branching factor</i>. Generating the children of a node adds <i>B</i> nodes to the agenda. We are interested in the following question: if a goal is found at depth <i>n</i> (i.e. the path from the root to the goal has length <i>n</i>), how many nodes are there on the agenda? Since at each level only the children of a single node are generated, the size of the agenda is of the order <i>B</i>
  <span class="AutoStyle09">
   &times;
  </span>
  <i>n</i>, that is, a linear function of the depth of the tree. The time complexity&nbsp;of depth-first search is of the order <i>B<span class="AutoStyle56">
    n
   </span></i>, since the runtime is proportional to the number of nodes searched, and in the worst case the goal is found in the last branch, after searching <i>B<span class="AutoStyle56">
    n
   </span></i> <b>&nbsp;</b> nodes. Of course, we cannot hope to achieve any better for blind exhaustive search!
 </p>
 <p class="sektie">
  In practice, depth-first search is only implemented as above if loop detection is an absolute must. Otherwise, the agenda is represented <i>implicitly</i> by means of Prolog&rsquo;s internal goal stack. Children of a given node are generated one at a time, by means of Prolog&rsquo;s backtracking&nbsp;mechanism, and examined immediately upon generation:
 </p>
 <p class="pi-eerst">
  % depth-first search by means of backtracking
 </p>
 <p class="pi">
  search_bt(Goal,Goal):-<br>
  goal(Goal).
</p>
 <p class="pi-laatst">
  search_bt(Current,Goal):-<br>
  arc(Current,Child),<br>
  search_bt(Child,Goal).
</p>
 <p class="tekst">
  If there is a chance that the search program gets trapped in an infinite loop, it might be a good idea to employ a predefined <i>depth bound</i>:
 </p>
 <p class="pi-eerst">
  % backtracking depth-first search with depth bound
 </p>
 <p class="pi">
  search_d(D,Goal,Goal):-<br>
  goal(Goal).
</p>
 <p class="pi-laatst">
  search_d(D,Current,Goal):-<br>
  D&gt;0, D1 is D-1,<br>
  arc(Current,Child),<br>
  search_d(D1,Child,Goal).
</p>
 <p class="tekst">
  In this way the search process is guaranteed to halt, but solutions which appear beyond the depth bound are missed.
 </p>
 <p class="sektie">
  <i>Iterative deepening</i>&nbsp;is a form of depth-first search which employs a depth bound that is increased on each iteration. That is, after performing a depth-first search with depth bound <i>d</i>, search starts all over again from the starting nodes with an increased depth bound <i>d</i> + <i>n</i>. The predicate <tt>search_id/2</tt> implements iterative deepening for <i>n</i> =1.
 </p>
 <p class="pi-eerst">
  % iterative deepening
 </p>
 <p class="pi-laatst">
  search_id(First,Goal):-<br>
  search_id(1,First,Goal).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% start with depth 1
</p>
 <p class="pi">
  search_id(D,Current,Goal):-<br>
  search_d(D,Current,Goal).
</p>
 <p class="pi-laatst">
  search_id(D,Current,Goal):-<br>
  D1 is D+1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% increase depth<br>
  search_id(D1,Current,Goal).
</p>


<div class="extract swish" id="search_id">
<pre class="source swish AutoStyle03" data-variant-id="group-1" id="search_id" query-text="?-search_id([a,d,a,m],Goal).">
% an example of iterative deepening
search_id(First,Goal):-
	search_id(1,First,Goal).     % start with depth 1

search_id(D,Current,Goal):-
	search_d(D,Current,Goal).
search_id(D,Current,Goal):-
	D1 is D+1,                   % increase depth
	search_id(D1,Current,Goal).

% backtracking depth-first search with depth bound
search_d(D,Goal,Goal):-
	goal(Goal).
search_d(D,Current,Goal):-
	D>0, D1 is D-1,
	arc(Current,Child),
	search_d(D1,Child,Goal).

children(Node,Children):-
	findall(C,arc(Node,C),Children).

% nodes are lists of letters
arc(T,[H|T]):-
	%length(T,N),N<11,	% depth bound no longer needed
	member(H,[a,d,i,m]).

% find palindromes
goal(L):-
    reverse(L,L).
</pre>
</div>


 <p class="tekst">
  A big advantage of iterative deepening&nbsp;over simple depth-first search is that iterative deepening is complete: it will find all the goals at depth <i>d</i> and less before proceeding to depth <i>d</i> + <i>n</i>. Moreover, if we set the depth increment <i>n</i> to 1, iterative deepening&nbsp;is also optimal: it will find shorter paths first. A disadvantage of iterative deepening is that upper parts of the search space are searched more than once (and goals in those upper parts are found more than once as well).
 </p>
 <h3 id="breadth_first_search">
  5.3&nbsp;&nbsp;&nbsp;Breadth-first search
 </h3>
 <p class="sektie1">
  Breadth-first search is realised by implementing the agenda as a first in&ndash;first out&nbsp;datastructure. That is, while removing nodes from the front of the list, they are added at the end:
 </p>
 <p class="pi-eerst">
  % breadth-first search
 </p>
 <p class="pi">
  search_bf([Goal|Rest],Goal):-<br>
  goal(Goal).
</p>
 <p class="pi-laatst">
  search_bf([Current|Rest],Goal):-<br>
  children(Current,Children),<br>
  append(Rest,Children,NewAgenda),<br>
  search_bf(NewAgenda,Goal).
</p>

<div class="extract swish" id="search_bf">
<pre class="source swish AutoStyle03" data-variant-id="group-1" id="search_bf" query-text="?-search_bf([[a,d,a,m]],Goal).">
% an example of breadth-first search
search_bf([Goal|_Rest],Goal):-
	goal(Goal).
search_bf([Current|Rest],Goal):-
	children(Current,Children),
	append(Rest,Children,NewAgenda),
	search_bf(NewAgenda,Goal).

children(Node,Children):-
	findall(C,arc(Node,C),Children).

% nodes are lists of letters
arc(T,[H|T]):-
	length(T,N),N<11,	% try removing the depth bound
	member(H,[a,d,i,m]).

% find palindromes
goal(L):-
    reverse(L,L).
</pre>
</div>

<div class="extract exercise" id="5.2">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 5.2.</i> Implement the predicate <tt>term_write_bf/1</tt>, which writes the tree represented by a term from the root downward (as opposed to the predicate <tt>term_write/1</tt> of section 4.1, which writes from left to right). Employ breadth-first search with two agendas, one for nodes at depth <i>n</i> and the other for nodes at depth <i>n</i> +1.
  </p>
 </div>
</div>
 <p class="sektie">
  In breadth-first search, the agenda is implemented as a queue. This means that the nodes on the agenda are ordered according to increasing depth: all the nodes on depth <i>n</i> occur before the nodes on depth <i>n</i> +1. This has profound consequences with regard to the properties of breadth-first search. First of all, <i>breadth-first search&nbsp;is complete</i>, even for infinite search spaces. This is so because every goal on depth <i>n</i> will be found before descending to depth <i>n</i> +1. Secondly, <i>breadth-first search&nbsp;always finds a shortest solution path</i>. It may seem that breadth-first search is much better than depth-first search. However, like every coin this one has a reverse side also: the number of nodes at depth <i>n</i> is <i>B<span class="AutoStyle56">
    n
   </span></i>, such that breadth-first search&nbsp;requires much more memory than depth-first search.
 </p>
 <p class="sektie">
  We will now show how to change Prolog&nbsp;into a <i>complete</i> SLD prover, by employing breadth-first search. We start from the meta-interpreter <tt>prove_r/1</tt> given in section 3.8:
 </p>
 <p class="pi-eerst">
  prove_r(true):-!.
 </p>
 <p class="pi">
  prove_r((A,B)):-!,<br>
  clause(A,C),<br>
  conj_append(C,B,D),<br>
  prove_r(D).
</p>
 <p class="pi-laatst">
  prove_r(A):-<br>
  clause(A,B),<br>
  prove_r(B).
</p>
 <p class="tekst">
  As explained in that section, this meta-interpreter operates on the complete resolvent, which is exactly what we need. This predicate is turned into an agenda-based depth-first search procedure as follows:
 </p>
 <p class="oms-eerst">
  % agenda-based version of prove_r/1
 </p>
 <p class="pi-laatst">
  prove_df(Goal):-<br>
  prove_df_a([Goal]).
</p>
 <p class="pi">
  prove_df_a([true|Agenda]).
 </p>
 <p class="pi">
  prove_df_a([(A,B)|Agenda]):-!,<br>
  findall(D,(clause(A,C),conj_append(C,B,D)),Children),<br>
  append(Children,Agenda,NewAgenda),<br>
  prove_df_a(NewAgenda).
</p>
 <p class="pi-laatst">
  prove_df_a([A|Agenda]):-<br>
  findall(B,clause(A,B),Children),<br>
  append(Children,Agenda,NewAgenda),<br>
  prove_df_a(NewAgenda).
</p>
 <p class="tekst">
  The changes are relatively straightforward: all solutions to the calls in the bodies of the second and third <tt>prove_r</tt> clauses are collected by means of the predicate <tt>findall/3</tt>, and added to the front of the agenda.
 </p>
 <p class="sektie">
  In order to search in a breadth-first fashion, we swap the first two arguments of the <tt>append/3</tt> literals. One additional improvement is required, since <tt>prove_df/1</tt> succeeds for every proof that can be found, but it does not return an answer substitution&nbsp;for the variables in the query. This is because the call <tt>findall(X,G,L)</tt> creates new variables for the unbound variables in the instantiation of <tt>X</tt> before putting it in the list <tt>L</tt>. In order to obtain an answer substitution, we should maintain the agenda as a list of pairs
 </p>
 <p class="p-el">
  a(Literals,OrigGoal)
 </p>
 <p class="tekst">
  where <tt>OrigGoal</tt> is a copy of the original goal. To illustrate this, suppose the following clauses are given:
 </p>
 <p class="p-el">
  likes(peter,Y):-student(Y),friendly(Y).<br>
  likes(X,Y):-friend(Y,X).<br>
  student(maria).<br>
  student(paul).<br>
  friendly(maria).<br>
  friend(paul,peter).
</p>
 <p class="tekst">
  Below, the agenda obtained after each breadth-first search iteration is given for the query <tt>?‑likes(X,Y)</tt>:
 </p>
 <p class="p-el">
  [ a((student(Y1),friendly(Y1)), likes(peter,Y1)),<br>
  &nbsp;a(friend(Y2,X2), likes(X2,Y2)) ]
</p>
 <p class="p-laatst">
  [ a(friend(Y2,X2), likes(X2,Y2))<br>
  &nbsp;a(friendly(maria), likes(peter,maria)),<br>
  &nbsp;a(friendly(paul), likes(peter,paul)) ]
</p>
 <p class="p-laatst">
  [ a(friendly(maria), likes(peter,maria)),<br>
  &nbsp;a(friendly(paul), likes(peter,paul)),<br>
  &nbsp;a(true, likes(peter,paul)) ]
</p>
 <p class="p-laatst">
  [ a(friendly(paul), likes(peter,paul)),<br>
  &nbsp;a(true, likes(peter,paul)),<br>
  &nbsp;a(true, likes(peter,maria)) ]
</p>
 <p class="p-laatst">
  [ a(true, likes(peter,paul)),<br>
  &nbsp;a(true, likes(peter,maria)) ]
</p>
 <p class="tekst">
  Here, <tt>Y1</tt>, <tt>X2</tt> and <tt>Y2</tt> denote new variables introduced by <tt>findall/3</tt>. It can be clearly seen that for each item <tt>a(R,G)</tt> on the agenda, <tt>R</tt> and <tt>G</tt> share the right variables &mdash; thus, whenever the resolvent gets more instantiated during the proof, the corresponding copy of the goal is instantiated correspondingly. In particular, if the empty clause is found on the agenda in the form of a term <tt>a(true,Goal)</tt>, then <tt>Goal</tt> will contain the correct answer substitutions.
 </p>
 <p class="sektie">
  The final, complete SLD prover looks as follows:
 </p>
 <p class="oms-eerst">
  % breadth-first version of prove_r/1 + answer substitution
 </p>
 <p class="pi-laatst">
  prove_bf(Goal):-<br>
  prove_bf_a([a(Goal,Goal)],Goal).
</p>
 <p class="pi">
  prove_bf_a([a(true,Goal)|Agenda],Goal).
 </p>
 <p class="pi">
  prove_bf_a([a((A,B),G)|Agenda],Goal):-!,<br>
  findall(a(D,G),<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(clause(A,C),conj_append(C,B,D)),<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Children),<br>
  append(Agenda,Children,NewAgenda),% breadth-first<br>
  prove_bf_a(NewAgenda,Goal).
</p>
 <p class="pi-laatst">
  prove_bf_a([a(A,G)|Agenda],Goal):-<br>
  findall(a(B,G),clause(A,B),Children),<br>
  append(Agenda,Children,NewAgenda),% breadth-first<br>
  prove_bf_a(NewAgenda,Goal).
</p>
 <p class="tekst">
  Notice that this program is able to find alternative solutions, since it will backtrack from the first clause into the third and, being unable to find a clause for the predicate <tt>true/0</tt>, <tt>findall/3</tt>&nbsp;will generate an empty list of children and search will proceed with the rest of the agenda.
 </p>
<div class="extract exercise" id="5.3">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 5.3.</i> Consider the following program:<br>
   <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother(peter,paul).<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother(adrian,paul).<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother(X,Y):-brother(Y,X).<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brother(X,Y):-brother(X,Z),brother(Z,Y).<br></tt> Compare and explain the behaviour of <tt>prove_bf/1</tt> and Prolog on the query <tt>?‑brother(peter,adrian)</tt>. Can you re-order the clauses, such that Prolog succeeds?
  </p>
 </div>
</div>
 <p class="sektie">
  As a second, related example of a breadth-first search program, we give a program for finding refutation proofs in full clausal logic. Object-level&nbsp;clauses are given by the predicate <tt>cl/1</tt>. Note that <tt>true</tt> denotes the empty body, while <tt>false</tt> denotes the empty head; thus, <tt>false:-true</tt> denotes the empty clause.
 </p>
 <p class="oms-eerst">
  % refute_bf(Clause) &lt;- Clause is refuted by clauses<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defined by cl/1<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(breadth-first search strategy)
</p>
 <p class="pi-laatst">
  refute_bf(Clause):-<br>
  refute_bf_a([a(Clause,Clause)],Clause).
</p>
 <p class="pi">
  refute_bf_a([a((false:-true),Clause)|Rest],Clause).
 </p>
 <p class="pi-laatst">
  refute_bf_a([a(A,C)|Rest],Clause):-<br>
  findall(a(R,C),(cl(Cl),resolve(A,Cl,R)),Children),<br>
  append(Rest,Children,NewAgenda),&nbsp;&nbsp;% breadth-first<br>
  refute_bf_a(NewAgenda,Clause).
</p>
 <p class="pi">
  % resolve(C1,C2,R) &lt;- R is the resolvent of C1 and C2.
 </p>
 <p class="pi">
  resolve((H1:-B1),(H2:-B2),(ResHead:-ResBody)):-<br>
  resolve(H1,B2,R1,R2),<br>
  disj_append(R1,H2,ResHead),<br>
  conj_append(B1,R2,ResBody).
</p>
 <p class="pi-laatst">
  resolve((H1:-B1),(H2:-B2),(ResHead:-ResBody)):-<br>
  resolve(H2,B1,R2,R1),<br>
  disj_append(H1,R2,ResHead),<br>
  conj_append(R1,B2,ResBody).
</p>
 <p class="pi">
  resolve((A;B),C,B,E):-<br>
  conj_remove_one(A,C,E).
</p>
 <p class="pi">
  resolve((A;B),C,(A;D),E):-<br>
  resolve(B,C,D,E).
</p>
 <p class="pi-laatst">
  resolve(A,C,false,E):-<br>
  conj_remove_one(A,C,E).
</p>
 <p class="p-laatst">
  %%% disj_append/3, conj_remove_one/3: see Appendix A.2
 </p>
 <p class="tekst">
  For instance, given the following clauses:
 </p>
 <p class="p-el">
  cl((bachelor(X);married(X):-man(X),adult(X))).<br>
  cl((has_wife(X):-man(X),married(X))).<br>
  cl((false:-has_wife(paul))).<br>
  cl((man(paul):-true)).<br>
  cl((adult(paul):-true)).
</p>
 <p class="tekst">
  and the query <tt>?-refute_bf((false:-bachelor(X)))</tt> (refute that no-one is a bachelor), the program answers <tt>X=paul</tt>. Note that there are many proofs for this answer!
 </p>
<div class="extract exercise" id="5.4">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 5.4</i>. Extend the meta-interpreter, such that it returns a proof tree (see section 3.8). In order to ensure correct variable substitutions, each item on the agenda must be extended with a partial proof tree.
  </p>
 </div>
</div>
 <p class="sektie">
  As a search program, the above program is complete. As a theorem prover, however, the program is incomplete.&nbsp;This is due to the resolution strategy&nbsp;used, in which every resolvent&nbsp;has at least one given clause as its parent. This strategy is called <i>input</i> resolution; it is refutation complete for definite clauses, but not for indefinite clauses.
 </p>
 <h3 id="forward_chaining">
  5.4&nbsp;&nbsp;&nbsp;Forward chaining
 </h3>
 <p class="sektie1">
  Search programs involving if-then rules, such as meta-interpreters and theorem provers, can use these rules in either of two directions: from body to head or forward, and from head to body or backward. The meta-interpreters we encountered up till now apply clauses backward, just like Prolog; they are said to perform <i>backward chaining</i>. For checking if a given formula follows logically from a given theory, this is usually the best strategy.
 </p>
 <p class="sektie">
  However, in some cases we must rather perform <i>forward chaining</i>, because we do not have a goal to start from. For instance, consider the problem of constructing a model of a given theory. It would not be feasible to generate all the ground atoms in the Herbrand base and follow the chains back to the theory. Rather, we would generate the model incrementally by forward chaining. The procedure is as follows:
 </p>
 <p class="opsomming">
  (<i>i</i>)&nbsp;&nbsp;&nbsp;search for a violated clause of which the body is true in the current model, but the head is not (such a clause is said to <i>fire</i>);
 </p>
 <p class="opsomming">
  (<i>ii</i>)&nbsp;&nbsp;add a literal from the head to the model
  <span class="CustomFootnote">
   <a href="#_ftn5" name="_ftnref5" title="">
    <span class="MsoFootnoteReference">
     <span class="AutoStyle13">
      <span class="AutoStyle14">
       [16]
      </span>
     </span>
    </span>
   </a>
  </span>
  .
 </p>
 <p class="tekst">
  By step (<i>ii</i>), the head (a disjunction) is made true in the model, so that this clause is no longer violated. The procedure iterates back to step (<i>i</i>); if no violated clauses remain, the model is complete.
 </p>
 <p class="sektie">
  The program for model generation&nbsp;by forward chaining is given below. It is a fairly simple forward chainer, in the sense that it simply chooses the first clause which fires. More sophisticated forward chainers use <i>conflict resolution</i>&nbsp;strategies in order to choose among the rules which fire at a certain stage.
 </p>
 
<div class="extract swish" id="model">
<pre class="source swish AutoStyle03" data-variant-id="group-1" id="model" query-text="?-model(M).">
% model(M) <- M is a model of the clauses defined by cl/1
model(M):-
	model([],M).

model(M0,M):-
	is_violated(Head,M0),!,% instance of violated clause
	disj_element(L,Head),  % L: ground literal from head
	model([L|M0],M).       % add L to the model
model(M,M).                 % no more violated clauses

is_violated(H,M):-
	cl((H:-B)),
	satisfied_body(B,M),   % grounds the variables
	\+ satisfied_head(H,M).

satisfied_body(true,_M).     % body is a conjunction
satisfied_body(A,M):-
	member(A,M).
satisfied_body((A,B),M):-
	member(A,M),
	satisfied_body(B,M).

satisfied_head(A,M):-       % head is a disjunction
	member(A,M).
satisfied_head((A;_B),M):-
	member(A,M).
satisfied_head((_A;B),M):-
	satisfied_head(B,M).

%%% from Appendix A.2
disj_element(X,X):-          % single-element disjunction
	X\=false,
	X\=(_;_).
disj_element(X,(X;_Ys)).
disj_element(X,(_Y;Ys)):-
	disj_element(X,Ys).

%%% Example disjunctive clauses to compute model for
cl((married(X);bachelor(X):-man(X),adult(X))).
cl((has_wife(X):-married(X),man(X))).
cl((man(paul):-true)).
cl((adult(paul):-true)).
</pre>
</div>

 <p class="tekst">
  Given the following clauses:
 </p>
 <p class="p-el">
  cl((married(X);bachelor(X):-man(X),adult(X))).<br>
  cl((has_wife(X):-married(X),man(X))).<br>
  cl((man(paul):-true)).<br>
  cl((adult(paul):-true)).
</p>
 <p class="tekst">
  and the query <tt>?-model(M)</tt>, the program constructs the following models (on backtracking):
 </p>
 <p class="p-el">
  M = [has_wife(paul),married(paul),adult(paul),man(paul)];
 </p>
 <p class="p-laatst">
  M = [bachelor(paul),adult(paul),man(paul)]
 </p>
 <p class="tekst">
  Notice that these are the two minimal models of the program.
 </p>
<div class="extract exercise" id="5.5">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 5.5</i>. Give the remaining models of the program.
  </p>
 </div>
</div>
 <p class="sektie">
  Not every model generated by <tt>model/1</tt> is minimal. Consider the following set of clauses:
 </p>
 <p class="p-el">
  cl((likes(peter,maria):-true)).<br>
  cl((student(maria):-true)).<br>
  cl((teacher(X);friendly(Y):-likes(X,Y),student(Y))).<br>
  cl((friendly(Y):-teacher(X),likes(X,Y))).
</p>
 <p class="tekst">
  <tt>is_violated/2</tt> will first succeed for the third clause, returning the instantiated head <tt>teacher(peter);friendly(maria)</tt>. The first literal in this head will be added to the model. Next, the fourth clause is violated, and <tt>friendly(maria)</tt> is added to the model. This results in the following model:
 </p>
 <p class="p-el">
  [friendly(maria),teacher(peter),<br>
  &nbsp;student(maria),likes(peter,maria)]
</p>
 <p class="tekst">
  However, this is not a minimal model since <tt>teacher(peter)</tt> can be removed from it, yielding the model
 </p>
 <p class="pi-el">
  [friendly(maria),student(maria),likes(peter,maria)]
 </p>
 <p class="tekst">
  which will be returned as the second answer.
 </p>
<div class="extract exercise" id="5.6">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 5.6</i>. Are all minimal models always constructed by <tt>model/1</tt>?
  </p>
 </div>
</div>
 <p class="sektie">
  It should be noted that the program only works properly for a restricted class of clauses, namely those clauses for which grounding the body also grounds the head. Otherwise, a head literal from a violated clause might still contain variables. Adding a non-ground literal to the model could result in incorrect behaviour. Consider the following set of clauses:
 </p>
 <p class="p-el">
  cl((man(X);woman(X):-true)).<br>
  cl((false:-man(maria))).<br>
  cl((false:-woman(peter))).
</p>
 <p class="tekst">
  Since the first clause is violated by the empty model, the program will attempt to add <tt>man(X)</tt> to the model. This leads to the second clause being violated, and since this clause has an empty head, it cannot be satisfied by adding a literal to the model. Upon backtracking <tt>woman(X)</tt> is tried instead, but this leads to a similar problem with the third clause. Consequently, <tt>model/1</tt> will fail to construct a model, although there exists one, namely { <tt>man(peter)</tt>, <tt>woman(maria)</tt> }.
 </p>
 <p class="sektie">
  The solution is to add a literal to the body of the first clause, which serves to enumerate the possible values for <tt>X</tt>:
 </p>
 <p class="p-el">
  cl((man(X);woman(X):-person(X))).<br>
  cl((person(maria):-true)).<br>
  cl((person(peter):-true)).<br>
  cl((false:-man(maria))).<br>
  cl((false:-woman(peter))).
</p>
 <p class="tekst">
  In this way, the first clause is violated only under the substitutions { <tt>X</tt>
  <span class="AutoStyle09">
   &rarr;
  </span>
  <tt>peter</tt> } and { <tt>X</tt>
  <span class="AutoStyle09">
   &rarr;
  </span>
  <tt>maria</tt> }. Thus, all literals which are added to the model are ground, and the program constructs the correct model
 </p>
 <p class="pi-el">
  [man(peter),person(peter),woman(maria),person(maria)]
 </p>
 <p class="tekst">
  Clauses of which all variables in the head occur also in the body are called <i>range-restricted</i>. Every set of clauses can be transformed into a set of range-restricted clauses by adding domain predicates enumerating the domains of variables, as above. The two sets of clauses are equivalent in the sense that there exists a one-to-one correspondence between their models:
 </p>
 <p class="opsomming AutoStyle64">
  &bull;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any model of the original clauses provides an enumeration of all the domains;
 </p>
 <p class="opsomming">
  &bull;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any model of the range-restricted clauses can be transformed to a model of the original clauses by dropping the domain literals.
 </p>
 <p class="sektie">
  Obviously, <tt>model/1</tt> loops if the model being constructed is infinite. This will happen, for instance, with the following set of clauses, representing a range-restricted version of the append predicate:
 </p>
 <p class="p-el">
  cl((append([],Y,Y):-list(Y))).<br>
  cl((append([X|Xs],Ys,[X|Zs]):-thing(X),append(Xs,Ys,Zs))).<br>
  cl((list([]):-true)).<br>
  cl((list([X|Y]):-thing(X),list(Y))).<br>
  cl((thing(a):-true)).<br>
  cl((thing(b):-true)).<br>
  cl((thing(c):-true)).
</p>
 <p class="tekst">
  Instead of the complete, infinite model, we might be interested in a subset over a universe of lists up to a given length. Such a &lsquo;submodel&rsquo; can be computed by a forward chaining procedure which stops after a prespecified number of steps. In this way, the procedure gets more of a &lsquo;breadth-first&rsquo; flavour. The program is given below:
 </p>
 <p class="oms-eerst">
  % model_d(D,M) &lt;- M is a submodel of the clauses<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defined by cl/1
</p>
 <p class="pi-laatst">
  model_d(D,M):-<br>
  model_d(D,[],M).
</p>
 <p class="pi">
  model_d(0,M,M).
 </p>
 <p class="pi-laatst">
  model_d(D,M0,M):-<br>
  D&gt;0,D1 is D-1,<br>
  findall(H,is_violated(H,M0),Heads),<br>
  satisfy_clauses(Heads,M0,M1),<br>
  model_d(D1,M1,M).
</p>
 <p class="pi">
  satisfy_clauses([],M,M).
 </p>
 <p class="pi-laatst">
  satisfy_clauses([H|Hs],M0,M):-<br>
  disj_element(D,H),<br>
  satisfy_clauses(Hs,[D|M0],M).
</p>
 <p class="tekst">
  <tt>model/1</tt> is replaced by <tt>model_d/2</tt>, which has an additional depth parameter. On each iteration, all the violated clauses are generated and satisfied.
 </p>
 <p class="sektie">
  Below, we illustrate the operation of the program on the above set of clauses, setting the depth to 4:
 </p>
 <p class="query">
  ?-model_d(4,M)
 </p>
 <p class="pi-laatst AutoStyle65">
  M = [list([a,c,a]), list([a,c,b]), list([a,c,c]),% D=4 %<br>
  list([a,b,a]), list([a,b,b]), list([a,b,c]),<br>
  list([a,a,a]), list([a,a,b]), list([a,a,c]),<br>
  list([b,c,a]), list([b,c,b]), list([b,c,c]),<br>
  list([b,b,a]), list([b,b,b]), list([b,b,c]),<br>
  list([b,a,a]), list([b,a,b]), list([b,a,c]),<br>
  list([c,c,a]), list([c,c,b]), list([c,c,c]),<br>
  list([c,b,a]), list([c,b,b]), list([c,b,c]),<br>
  list([c,a,a]), list([c,a,b]), list([c,a,c]),<br>
  append([a],[a],[a,a]), append([a],[b],[a,b]),<br>
  append([a],[c],[a,c]), append([a,c],[],[a,c]),<br>
  append([a,b],[],[a,b]), append([a,a],[],[a,a]),<br>
  append([b],[a],[b,a]), append([b],[b],[b,b]),<br>
  append([b],[c],[b,c]), append([b,c],[],[b,c]),<br>
  append([b,b],[],[b,b]), append([b,a],[],[b,a]),<br>
  append([c],[a],[c,a]), append([c],[b],[c,b]),<br>
  append([c],[c],[c,c]), append([c,c],[],[c,c]),<br>
  append([c,b],[],[c,b]), append([c,a],[],[c,a]),<br>
  append([],[c,a],[c,a]), append([],[c,b],[c,b]),<br>
  append([],[c,c],[c,c]), append([],[b,a],[b,a]),<br>
  append([],[b,b],[b,b]), append([],[b,c],[b,c]),<br>
  append([],[a,a],[a,a]), append([],[a,b],[a,b]),<br>
  append([],[a,c],[a,c]),<br>
  list([a,c]), list([a,b]), list([a,a]),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% D=3 %<br>
  list([b,c]), list([b,b]), list([b,a]),<br>
  list([c,c]), list([c,b]), list([c,a]),<br>
  append([a],[],[a]), append([b],[],[b]),<br>
  append([c],[],[c]), append([],[c],[c]),<br>
  append([],[b],[b]), append([],[a],[a]),<br>
  list([a]), list([b]), list([c]),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% D=2 %<br>
  append([],[],[]),<br>
  thing(c), thing(b), thing(a),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% D=1 %<br>
  list([])&nbsp;]
</p>
 <p class="tekst">
  At depth 1, only domain clauses are satisfied; at depth 2 the first <tt>append</tt> literal appears. Depths 3 and 4 add <tt>list</tt> literals for all lists of length 2 and 3, and <tt>append</tt> literals for all lists of length 1 and 2, respectively.
 </p>
 <h3 id="further_reading_5">
  Further reading
 </h3>
 <p class="sektie1">
  Korf (1987) gives a comprehensive overview of search methods in Artificial Intelligence. He is also the originator of the iterative deepening&nbsp;search strategy (Korf, 1985). The model generation&nbsp;program in section 5.4 is adapted from (Manthey &amp; Bry, 1988).
 </p>
 <p class="referenties">
  <span class="AutoStyle41">
   R.E. Korf (
  </span>
  1985)
  <span class="AutoStyle41">
   ,
  </span>
  &lsquo;Depth-first iterative deepening: an optimal admissible tree search&rsquo;, <i>Artificial Intelligence</i> <b>27</b>: 97-109.
 </p>
 <p class="referenties">
  <span class="AutoStyle41">
   R.E. Korf (
  </span>
  1987)
  <span class="AutoStyle41">
   ,
  </span>
  &lsquo;Search&rsquo;. In <i>Encyclopedia of Artificial Intelligence</i>, S.C. Shapiro (ed.), pp. 994-998, John Wiley.
 </p>
 <p class="referenties AutoStyle66">
  <span class="AutoStyle41">
   R. Manthey &amp; F. Bry (
  </span>
  1988)
  <span class="AutoStyle41">
   ,
  </span>
  &lsquo;SATCHMO: a theorem prover implemented in Prolog&rsquo;. In E. Lusk &amp; R. Overbeek (eds), <i>Proc. 9th International Conference on Automated Deduction</i>, Lecture Notes in Computer Science 310, pp. 415-434, Springer‑Verlag.
 </p>
</div>
<b>
 <span class="AutoStyle02">
  <br clear="all"/>
 </span>
</b>
<div class="WordSection4">
 <p class="cijfer" id="informed_search">
  6
 </p>
 <h2 id="h_informed_search">
  Informed search
 </h2>
 <p class="sektie1">
  The search strategies of the previous chapter do not make any assumptions about the plausibility of a certain node in the search space leading to a goal. Such a form of search is called <i>blind</i> search. Alternatively, search strategies which <b>do</b> make such assumptions are called <i>informed</i> search&nbsp;strategies. The extra information which is incorporated in the search process is provided by an evaluation function <i>h</i> called a <i>heuristic</i>, which estimates how far a given node is from a goal. This information can be used in several ways. If we use it to order the nodes on the agenda, such that most promising nodes are tried first, the resulting search method is called <i>best-first</i> search. In section 6.2, we will discuss a complete variant of best-first search called the <i>A algorithm</i>, and investigate the conditions under which this algorithm is optimal. In section 6.3, we will discuss non-exhaustive informed search strategies, that can be derived from best-first search by limiting the size of the agenda.
 </p>
 <h3 id="best_first_search">
  6.1&nbsp;&nbsp;&nbsp;Best-first search
 </h3>
 <p class="sektie1">
  We will assume that a predicate <tt>eval/2</tt>&nbsp;is defined, which returns for a given node in the search space an estimate of the distance between that node and a goal node. The children of the current node are added to the agenda according to their heuristic evaluation (lowest values first). Thus, the agenda will always be sorted.
 </p>
 <p class="oms-eerst">
  % best-first search<br>
  % goal/1, children/2 and eval/2 depend on<br>
  % the search problem at hand
</p>
 <p class="pi">
  search_bstf([Goal|Rest],Goal):-<br>
  goal(Goal).
</p>
 <p class="pi-laatst">
  search_bstf([Current|Rest],Goal):-<br>
  children(Current,Children),<br>
  add_bstf(Children,Rest,NewAgenda),<br>
  search_bstf(NewAgenda,Goal).
</p>
 <p class="oms">
  % add_bstf(A,B,C) &lt;- C contains the elements of A and B<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B and C sorted according to eval/2)
</p>
 <p class="pi">
  add_bstf([],Agenda,Agenda).
 </p>
 <p class="pi-laatst">
  add_bstf([Child|Children],OldAgenda,NewAgenda):-<br>
  add_one(Child,OldAgenda,TmpAgenda),<br>
  add_bstf(Children,TmpAgenda,NewAgenda).
</p>
 <p class="oms">
  % add_one(S,A,B) &lt;- B is A with S inserted acc. to eval/2
 </p>
 <p class="pi-laatst">
  add_one(Child,OldAgenda,NewAgenda):-<br>
  eval(Child,Value),<br>
  add_one(Value,Child,OldAgenda,NewAgenda).
</p>
 <p class="pi">
  add_one(Value,Child,[],[Child]).
 </p>
 <p class="pi">
  add_one(Value,Child,[Node|Rest],[Child,Node|Rest]):-<br>
  eval(Node,V),<br>
  Value&lt;V.
</p>
 <p class="pi-laatst">
  add_one(Value,Child,[Node|Rest],[Node|NewRest]):-<br>
  eval(Node,V),<br>
  Value&gt;=V,<br>
  add_one(Value,Child,Rest,NewRest).
</p>
 <p class="tekst">
  <tt>add_bstf/3</tt> operates by inserting the new children one by one in the current agenda. Note that if the list of children were already sorted, it could more efficiently be <b>merged</b> with the current agenda.
 </p>
<div class="extract exercise" id="6.1">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 6.1.</i> Suppose the call <tt>children(Current,Children)</tt> results in an ordered list of children. Write a predicate <tt>merge/3</tt> which directly merges this list with the current agenda.
  </p>
 </div>
</div>
 <div class="extract figure" id="6.1">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle20">
      <p class="med-figure AutoStyle07">
       <img src="img/part_ii/image016.svg" v:shapes="Picture_x0020_9" width="100%">
       </img>
      </p>
     </div>
     <p class="med-caption">
      <b>Figure   6.1.</b> Initial board position.
     </p>
    </td>
   </tr>
  </table>
 </div>
 <p class="sektie">
  As an application of best-first search, consider the following puzzle. We have a board consisting of seven consecutive squares, three black tiles and three white tiles, initially placed on the board as in fig. 6.1. The goal is to move the tiles in such a way that the black tiles are to the right of the white tiles (the position of the empty square is immaterial). Each move consists of moving one tile into the empty square, which is allowed if there are at most two other tiles in between. The cost of such a move is 1 if there are no tiles in between, and equals the number of tiles jumped over otherwise.
 </p>
 <p class="sektie">
  This puzzle defines a search space, in which nodes are board positions and arcs are single moves. We choose a simple list representation for board positions: e.g. <tt>[b,b,b,e,w,w,w]</tt> represents the starting position of fig. 6.1. The following predicates examine and manipulate board positions:
 </p>

<div class="extract swish" id="get_tile">
<pre class="source swish temp AutoStyle03" data-variant-id="group-1" id="get_tile" query-text="?-get_tile([b,b,b,e,w,w,w],N,T). ?-replace([b,b,b,e,w,w,w],3,e,Pos).">
% get_tile(P,N,T) <- pos. P contains tile T at square N
get_tile(Pos,N,T):-
	get_tile(Pos,1,N,T).

get_tile([X|_Xs],N,N,X).
get_tile([_X|Xs],N0,N,Y):-
	N1 is N0+1,
	get_tile(Xs,N1,N,Y).

% replace(P,N,T,P1) <- P1 is P with tile T at square N
replace([_X|Xs],1,Y,[Y|Xs]).
replace([X|Xs],N,Y,[X|Zs]):-
	N>1, N1 is N-1,
	replace(Xs,N1,Y,Zs).
</pre>
</div>

 <div class="extract infobox" id="when_not_to_use_lists">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle31">
      <p class="inter-title AutoStyle32">
       When not to use lists
      </p>
      <p class="intermezzo AutoStyle33">
       Recall (section 1.3) that <tt>[b,b,b,e,w,w,w]</tt> is an alternative notation for the term <tt>.(b,.(b,.(b,.(e,.(w,.(w,.(w,[])))))))</tt>. This term contains, besides the seven constants in the linear   notation, one additional constant (&lsquo; <tt>[]</tt> &rsquo;) and seven functors (&lsquo; <tt>.</tt> &rsquo;), each with   two arguments. In contrast, a &lsquo;flat&rsquo; term <tt>p(b,b,b,e,w,w,w)</tt> contains   only one additional functor, with seven arguments. Recursive datastructures   like lists are useful if the number of items to be stored is not fixed, but   they require significantly more storage space. In general, if the number of   items is fixed, a non-recursive datastructure is preferred as far as memory is   concerned. Given a term <tt>T</tt> holding the items, the call <tt>arg(N,T,A)</tt> retrieves the <tt>N</tt> th argument <tt>A</tt>. However, <tt>arg/3</tt> requires <tt>N</tt> to be instantiated, and cannot be used to generate all arguments on   backtracking. Therefore, lists are sometimes used even if the nature of the   data is non-recursive.
      </p>
     </div>
    </td>
   </tr>
  </table>
 </div>
 <p class="sektie">
  We use the above best-first search procedure, with a number of changes. First, rather than returning the goal position found, the program should construct a sequence of moves by which the goal position is reached. Therefore, nodes that are examined during the search process are collected in the list <tt>Visited</tt>. After a goal position has been found, the solution path and its total cost are reconstructed from the list <tt>Visited</tt> by means of the predicate <tt>construct_moves/6</tt>.
 </p>
 <p class="sektie">
  Secondly, the items on the agenda are represented as pairs <tt>v(Value,Move)</tt>, where <tt>Value</tt> is the heuristic evaluation of the position reached by <tt>Move</tt>. Children of the current position are generated by means of the <tt>setof/3</tt>&nbsp;predicate, which yields a <b>sorted</b> list. By putting the heuristic <tt>Value</tt> as the first argument of the functor <tt>v</tt>, the list <tt>Children</tt> is therefore sorted according to increasing heuristic value. Therefore, this list can be simply merged with the current agenda to yield the new agenda. The program thus looks as follows:
 </p>
 <p class="oms-eerst">
  % tiles(M,C) &lt;- moves M lead to a goal position at cost C<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(best-first search strategy)
</p>
 <p class="pi-laatst">
  tiles(Moves,Cost):-<br>
  start(Start),<br>
  eval(Start,Value),<br>
  tiles_a([v(Value,Start)],Final,[],Visited),<br>
  construct_moves(Final,Visited,[],Moves,0,Cost).
</p>
 <p class="pi">
  % tiles_a(A,M,V0,V) &lt;- goal position can be reached from
 </p>
 <p class="pi">
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one of the positions on A with last
 </p>
 <p class="pi">
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move M (best-first strategy)
 </p>
 <p class="pi">
  tiles_a([v(V,LastMove)|Rest],LastMove,Visited,Visited):-<br>
  goal(LastMove).
</p>
 <p class="pi-laatst">
  tiles_a([v(V,LastMove)|Rest],Goal,Visited0,Visited):-<br>
  show_move(LastMove,V),<br>
  setof0(v(Value,NextMove),<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( move(LastMove,NextMove),<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eval(NextMove,Value) ),<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Children),<br>
  merge(Children,Rest,NewAgenda),&nbsp;&nbsp;&nbsp;% best-first<br>
  tiles_a(NewAgenda,Goal,[LastMove|Visited0],Visited).
</p>
 <p class="pi-laatst">
  %%% merge/3: see exercise 6.1
 </p>
 <p class="tekst">
  <tt>setof0/3</tt>&nbsp;is a variant of <tt>setof/3</tt> which succeeds with the empty list if no solutions can be found (see Appendix A.2).
 </p>
 <p class="sektie">
  A move from <tt>OldPos</tt> to <tt>NewPos</tt> is represented by a triple
 </p>
 <p class="p-el">
  m(OldPos,NewPos,Cost)
 </p>
 <p class="tekst">
  where <tt>Cost</tt> specifies the cost of the move. According to the principle of data abstraction, this representation is kept local to the following predicates:
 </p>
 <p class="oms-eerst">
  % move(m(X,P,Y),m(P,NP,C)) &lt;- position NP can be reached<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from position P in one move<br>
  %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at cost C
</p>
 <p class="pi-laatst">
  move(m(OldPos,Pos,OldCost),m(Pos,NewPos,Cost)):-<br>
  get_tile(Pos,Ne,e),get_tile(Pos,Nbw,BW),not(BW=e),<br>
  Diff is abs(Ne-Nbw),Diff&lt;4,<br>
  replace(Pos,Ne,BW,Pos1),<br>
  replace(Pos1,Nbw,e,NewPos),<br>
  ( Diff=1&nbsp;&nbsp;&nbsp;-&gt; Cost=1<br>
  ; otherwise -&gt; Cost is Diff-1 ).
</p>
 <p class="pi-laatst">
  start(m(noparent,[b,b,b,e,w,w,w],0)).
 </p>
 <p class="oms">
  % reconstruct total cost and path from visited nodes
 </p>
 <p class="pi">
  construct_moves(m(noparent,Start,0),V,Ms,[Start|Ms],Cost,Cost).
 </p>
 <p class="pi-laatst">
  construct_moves(m(P,Pos,C),Visited,Ms0,Ms,Cost0,Cost):-<br>
  element(m(GP,P,C1),Visited),&nbsp;% GP is parent of P<br>
  Cost1 is Cost0+C,<br>
  construct_moves(m(GP,P,C1),Visited,[Pos|Ms0],Ms,Cost1,Cost).
</p>
 <p class="pi-laatst">
  show_move(m(P,Pos,C),Value):-<br>
  write(Pos-Value),nl.
</p>
 <p class="sektie">
  Finally, we have to choose a heuristic evaluation function. A first idea is to count, for each white tile, the number of black tiles to the left of it:
 </p>
 <p class="pi-el">
  goal(LastMove):-<br>
  eval(LastMove,0).
</p>
 <p class="pi-laatst">
  eval(m(P,Pos,C),Value):-<br>
  bLeftOfw(Pos,Value).
</p>
 <p class="pi-laatst">
  bLeftOfw(Pos,Value):-<br>
  findall((Nb,Nw),<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(get_tile(Pos,Nb,b),get_tile(Pos,Nw,w),Nb&lt;Nw),<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L),<br>
  length(L,Value).
</p>
 <p class="tekst">
  Note that this program actually <i>counts</i> the number of solutions to the query
 </p>
 <p class="p-el">
  ?-get_tile(Pos,Nb,b),get_tile(Pos,Nw,w),Nb&lt;Nw.
 </p>
 <p class="tekst">
  by determining the length of the list that is returned by the second-order predicate <tt>findall/3</tt>.
 </p>
<div class="extract exercise" id="6.2">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 6.2.</i> Rewrite <tt>bLeftOfw/2</tt> such that it uses only first-order predicates.
  </p>
 </div>
</div>
 <p class="sektie">
  The program writes every move it considers on the screen, together with its heuristic evaluation. For instance, the query
 </p>

<div class="extract swish" id="tiles">
<pre class="source swish AutoStyle03" data-variant-id="group-1" id="tiles" query-text="?-tiles(M,C)." source-text-end="
% tiles(M,C) <- moves M lead to a goal position at cost C 
%               (best-first search strategy)
tiles(Moves,Cost):-
	start(Start),
	eval(Start,Value),
	tiles_a([v(Value,Start)],Final,[],Visited),
	construct_moves(Final,Visited,[],Moves,0,Cost).

% tiles_a(A,M,V0,V) <- goal position can be reached from one of the
%                      positions on A with last move M (best-first)
%                      (V is list of visited nodes, V0 is accumulator)
tiles_a([v(_V,LastMove)|_Rest],LastMove,Visited,Visited):-
	goal(LastMove).
tiles_a([v(V,LastMove)|Rest],Goal,Visited0,Visited):-
	show_move(LastMove,V),
	setof0(v(Value,NextMove),
        (move(LastMove,NextMove),eval(NextMove,Value)),
        Children),
	merge(Children,Rest,NewAgenda),	% best-first
	tiles_a(NewAgenda,Goal,[LastMove|Visited0],Visited).

/*
merge([],Agenda,Agenda).
merge([C|Cs],[],[C|Cs]).
merge([v(V1,Move1)|Rest1],[v(V2,Move2)|Rest2],[v(V1,Move1)|Rest3]):-
	V1<V2,
	merge(Rest1,[v(V2,Move2)|Rest2],Rest3).
merge([v(V1,Move1)|Rest1],[v(V2,Move2)|Rest2],[v(V2,Move2)|Rest3]):-
	V1>=V2,
	merge([v(V1,Move1)|Rest1],Rest2,Rest3).
*/

% move(m(X,P,Y),m(P,NP,C)) <- position NP can be reached from current 
%                             position P in one move at cost C
move(m(_OldPos,Pos,_OldCost),m(Pos,NewPos,Cost)):-
	get_tile(Pos,Ne,e),get_tile(Pos,Nbw,BW),not(BW=e),
	D is Ne-Nbw,
	( D<0       -> Diff is -D
	; otherwise -> Diff is D ),	% Diff is abs(Ne-Nbw)
	Diff<4,
	replace(Pos,Ne,BW,Pos1),
	replace(Pos1,Nbw,e,NewPos),
	( Diff=1    -> Cost=1
	; otherwise -> Cost is Diff-1 ).

% reconstruct total cost and path from list of visited nodes
construct_moves(m(noparent,Start,0),_Visited,Moves,[Start|Moves],Cost,Cost).
construct_moves(m(Parent,Pos,C),Visited,Moves0,Moves,Cost0,Cost):-
	member(m(GP,Parent,C1),Visited),	% GP is parent of Parent
	Cost1 is Cost0+C,
	construct_moves(m(GP,Parent,C1),Visited,[Pos|Moves0],Moves,Cost1,Cost).

start(m(noparent,[b,b,b,e,w,w,w],0)).

show_move(m(_P,Pos,_C),Value):-
	write(Pos-Value),nl.

get_tile(Pos,N,S):-
	get_tile(Pos,1,N,S).

get_tile([X|_Xs],N,N,X).
get_tile([_X|Xs],N0,N,Y):-
	N1 is N0+1,
	get_tile(Xs,N1,N,Y).

replace([_X|Xs],1,Y,[Y|Xs]).
replace([X|Xs],N,Y,[X|Zs]):-
	N>1,N1 is N-1,
	replace(Xs,N1,Y,Zs).

goal(LastMove):-
	eval(LastMove,0).

eval(m(_P,Pos,_C),Value):-
	bLeftOfw(Pos,Value).
%	outOfPlace(Pos,1,0,Value).

bLeftOfw(Pos,Value):-
	findall(b,(get_tile(Pos,Nb,b),get_tile(Pos,Nw,w),Nb<Nw),L),
	length(L,Value).

outOfPlace(_Pos,8,N,N).
outOfPlace(Pos,K,N0,N):-
	K<8, K1 is K+1,
	( K<4,get_tile(Pos,K,b) -> N1 is N0-(K-4)
	; K>4,get_tile(Pos,K,w) -> N1 is N0+(K-4)
	; otherwise -> N1=N0 ),
	outOfPlace(Pos,K1,N1,N).

setof0(X,Q,L):-setof(X,Q,L),!.
setof0(_X,_Q,[]).
">
%%% all above code taken together %%%
</pre>
</div>

 <p class="p-el">
  ?-tiles(M,C).
 </p>
 <p class="tekst">
  results in the following output:
 </p>
 <p class="p-eerst">
  [b,b,b,e,w,w,w]-9<br>
  [b,b,b,w,e,w,w]-9<br>
  [b,b,e,w,b,w,w]-8<br>
  [b,b,w,w,b,e,w]-7<br>
  [b,b,w,w,b,w,e]-7<br>
  [b,b,w,w,e,w,b]-6<br>
  [b,e,w,w,b,w,b]-4
</p>
 <p class="programma">
  [b,w,e,w,b,w,b]-4<br>
  [e,w,b,w,b,w,b]-3<br>
  [w,w,b,e,b,w,b]-2<br>
  [w,w,b,w,b,e,b]-1
</p>
 <p class="pi AutoStyle67">
  M = [[b,b,b,e,w,w,w],[b,b,b,w,e,w,w],[b,b,e,w,b,w,w],<br>
  [b,b,w,w,b,e,w],[b,b,w,w,b,w,e],[b,b,w,w,e,w,b],<br>
  [b,e,w,w,b,w,b],[b,w,e,w,b,w,b],[e,w,b,w,b,w,b],<br>
  [w,w,b,e,b,w,b],[w,w,b,w,b,e,b],[w,w,e,w,b,b,b]]
</p>
 <p class="pi-laatst">
  C = 15
 </p>
 <p class="tekst">
  Since the only moves that are considered are those that are on the final solution path, there is no backtracking. This seems to suggest that the heuristic works quite well. On the other hand, the first few moves seem a bit awkward: in particular, the first and the fourth move are relatively expensive.
 </p>
 <p class="sektie">
  Let&rsquo;s try another heuristic, which counts the number of tiles out of place: a wrong tile on the first or seventh square gives 3, on the second or sixth square 2, and on the third or fifth square 1.
 </p>
 <p class="pi-el">
  eval(Pos,Value):-<br>
  outOfPlace(Pos,1,0,Value).
</p>
 <p class="pi">
  outOfPlace(Pos,8,N,N).
 </p>
 <p class="pi-laatst">
  outOfPlace(Pos,K,N0,N):-<br>
  K&lt;8, K1 is K+1,<br>
  ( K&lt;4,get_tile(Pos,K,b) -&gt; N1 is N0-(K-4)<br>
  ; K&gt;4,get_tile(Pos,K,w) -&gt; N1 is N0+(K-4)<br>
  ; otherwise -&gt; N1=N0 ),<br>
  outOfPlace(Pos,K1,N1,N).
</p>
 <p class="tekst">
  We get the following result:
 </p>
 <p class="p-eerst">
  [b,b,b,e,w,w,w]-12<br>
  [b,b,b,w,w,w,e]-9<br>
  [e,b,b,b,w,w,w]-9<br>
  [b,b,b,w,w,e,w]-10<br>
  [b,b,b,w,w,w,e]-9<br>
  [b,b,e,w,w,b,w]-9<br>
  [e,b,b,w,w,b,w]-7<br>
  [w,b,b,e,w,b,w]-7<br>
  [w,b,b,w,w,b,e]-4<br>
  [w,b,b,w,w,e,b]-4<br>
  [w,b,e,w,w,b,b]-3<br>
  [w,b,w,w,e,b,b]-2
</p>
 <p class="pi AutoStyle67">
  M = [[b,b,b,e,w,w,w],[b,b,b,w,w,e,w],[b,b,e,w,w,b,w],<br>
  [e,b,b,w,w,b,w],[w,b,b,e,w,b,w],[w,b,b,w,w,b,e],<br>
  [w,b,b,w,w,e,b],[w,b,e,w,w,b,b],[w,b,w,w,e,b,b],<br>
  [w,e,w,w,b,b,b]]
</p>
 <p class="pi-laatst">
  C = 14
 </p>
 <p class="tekst">
  We observe a couple of differences with the previous heuristic. First of all, there is backtracking: the first, second and fourth moves are not pursued any further. Furthermore, the solution found requires two moves less, and is also cheaper.
 </p>
 <div class="extract figure" id="6.2">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle05">
      <p class="figure">
       <img src="img/part_ii/image018.svg" v:shapes="Picture_x0020_10" width="100%">
       </img>
      </p>
     </div>
     <p class="Caption1">
      <b>Figure   6.2.</b> Solutions found for different heuristics.
     </p>
    </td>
   </tr>
  </table>
 </div>
 <p class="sektie">
  This improvement seems to suggest that an increased punishment for wrongly placed tiles might lead to an even cheaper solution. For instance, we could increase the punishment to 4, 3 and 2, respectively, by adapting the predicate <tt>outOfPlace/4</tt> (try it!). This leads to the following sequence of moves:
 </p>
 <p class="p-eerst">
  [b,b,b,e,w,w,w]-18<br>
  [b,b,b,w,w,w,e]-14<br>
  [e,b,b,b,w,w,w]-14<br>
  [b,b,b,w,w,e,w]-15<br>
  [b,b,e,w,w,b,w]-13<br>
  [b,b,w,w,e,b,w]-11<br>
  [b,e,w,w,b,b,w]-8<br>
  [e,b,w,w,b,b,w]-7<br>
  [w,b,e,w,b,b,w]-7<br>
  [w,e,b,w,b,b,w]-6<br>
  [e,w,b,w,b,b,w]-6<br>
  [w,w,b,e,b,b,w]-6<br>
  [w,w,b,w,b,b,e]-2<br>
  [w,w,b,w,b,e,b]-2
</p>
 <p class="pi AutoStyle67">
  M = [[b,b,b,e,w,w,w],[b,b,b,w,w,e,w],[b,b,e,w,w,b,w],<br>
  [b,b,w,w,e,b,w],[b,e,w,w,b,b,w],[e,b,w,w,b,b,w],<br>
  [w,b,e,w,b,b,w],[w,e,b,w,b,b,w],[w,w,b,e,b,b,w],<br>
  [w,w,b,w,b,b,e],[w,w,b,w,b,e,b],[w,w,e,w,b,b,b]]
</p>
 <p class="pi-laatst">
  C = 15
 </p>
 <p class="tekst">
  Obviously, this heuristic works no better than the previous two: it does not find an optimal solution, and it investigates more moves than the first heuristic. In fig. 6.2, the solutions found by the three heuristics are compared. In the next section, we will investigate the conditions under which a heuristic&nbsp;is guaranteed to find an optimal solution.
 </p>
 <h3 id="optimal_best_first_search">
  6.2&nbsp;&nbsp;&nbsp;Optimal best-first search
 </h3>
 <p class="sektie1">
  Best-first search is an exhaustive search&nbsp;strategy, with a possible behaviour ranging from depth-first search to breadth-first search, depending on the heuristic used. By itself, best-first search is not complete: the heuristic might consistently assign lower values to the nodes on an infinite path.&nbsp;This is because the heuristic evaluation only takes into account an estimate of the distance to a goal, while we are actually interested in minimising the <b>total cost</b> of reaching a goal along a particular path. In order to obtain a complete best-first search algorithm, we use an evaluation function <i>f</i> consisting of two components:
 </p>
 <p class="formule AutoStyle68">
  <i>f</i> (<i>n</i>) = <i>g</i> (<i>n</i>) + <i>h</i> (<i>n</i>)
 </p>
 <p class="tekst">
  Here, <i>h</i> (<i>n</i>) is the heuristic estimate of the cost of reaching a goal node from node <i>n</i>, as it was introduced before. <i>g</i> (<i>n</i>) is the actual cost of reaching <i>n</i> from the starting node. Their sum <i>f</i> (<i>n</i>) is used to order the nodes on the agenda.
 </p>
 <p class="sektie">
  A best-first search algorithm which uses such an evaluation function <i>f</i> to estimate the total cost of a path is called an <i>A algorithm</i>. An A algorithm&nbsp;is complete, since the depth count <i>g</i> (<i>n</i>) will prevent search from getting trapped in an infinite path. In effect, the depth count will give the search strategy more of a breadth-first flavour. Indeed, breadth-first search is a special case of an A algorithm, with <i>h</i> (<i>n</i>)=0 for every node <i>n</i>. A disadvantage of A algorithms is the decreased efficiency&nbsp;associated with this breadth-first flavour.
 </p>
<div class="extract exercise" id="6.3">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 6.3.</i> Change the <tt>tiles</tt> program into an A algorithm, by associating with each move the <i>g</i> -value of the position reached by that move (i.e. the cost of the path leading to that position, instead of the cost of the last move). Demonstrate the decreased efficiency of the search.
  </p>
 </div>
</div>
 <p class="sektie">
  Breadth-first search is not only complete, it is also optimal: it always returns a shortest solution path
  <span class="CustomFootnote">
   <a href="#_ftn6" name="_ftnref6" title="">
    <span class="MsoFootnoteReference">
     <span class="AutoStyle13">
      <span class="AutoStyle14">
       [17]
      </span>
     </span>
    </span>
   </a>
  </span>
  . Do A algorithms inherit this property from breadth-first search? Obviously, this depends on the function <i>h</i>: if a node <i>n</i>
  <span class="AutoStyle10">
   1
  </span>
  &nbsp;on the cheapest path gets an <i>h</i> -estimate that is too high, other nodes will be tried instead, and a solution along a non-optimal path may be found first. We say that the heuristic&nbsp;was too <i>pessimistic</i> regarding <i>n</i>
  <span class="AutoStyle10">
   1
  </span>
  . Conversely, a heuristic which never assigns a value to a node that is higher than the actual cost of reaching a goal state from that node is called <i>optimistic</i>.
 </p>
 <p class="sektie">
  For instance, consider the first heuristic for the puzzle in the previous section, which counts for each white tile the number of black tiles to the left of it. Suppose one black tile has <i>w</i> white tiles to its right, which adds <i>w</i> to the heuristic value for that position. In order to reach a goal position, the black tile has to jump over some of the white tiles, while the remaining white tiles have to jump over the black tile; this has a cost of at least <i>w</i>. Therefore, this heuristic is optimistic. The second heuristic, calculating a weighted sum of tiles out of place, is also optimistic. For instance, suppose that a black tile is at the first square, then there are three white tiles to its right, over which it must jump. Analogously, if it is on the second square, then there are at least two white tiles to jump over. In contrast, the weights used in the third heuristic are too high.
 </p>
<div class="extract exercise" id="6.4">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 6.4.</i> Find a position for which the third heuristic is too pessimistic.
  </p>
 </div>
</div>
 <p class="sektie">
  It is possible to prove the following important result: <i>an A algorithm with an optimistic heuristic h always results in an optimal solution</i>. The resulting algorithm is called <i>A*</i>&nbsp;(A star); both A* search and optimistic heuristics are said to be <i>admissible</i>.&nbsp;This should not be mistaken to suggest that better heuristics are more optimistic! On the contrary, a good heuristic is as pessimistic as possible, without becoming non-admissible. In general, if <i>h</i>
  <span class="AutoStyle10">
   1
  </span>
  (<i>n</i>)&ge; <i>h</i>
  <span class="AutoStyle10">
   2
  </span>
  (<i>n</i>) for any node <i>n</i>, then we call heuristic <i>h</i>
  <span class="AutoStyle10">
   1
  </span>
  &nbsp;at least as <i>informed</i>&nbsp;as <i>h</i>
  <span class="AutoStyle10">
   2
  </span>
  . It can be shown that a more informed heuristic indeed searches a smaller part of the search space.
 </p>
 <p class="sektie">
  As a small example, consider the search space in fig. 6.3. The <i>h</i> -values for each node are as indicated; the cost per arc is 1. The heuristic is optimistic, so A* search will return the shortest path <i>start-r-s-goal</i>. However, this path is not found immediately: since both <i>p</i> and <i>q</i> have a lower <i>f</i> -value than <i>r</i>, they are investigated first. After <i>q</i> has been investigated, <i>s</i> is put on the agenda with <i>f</i> -value 3+1=4. Since <i>r</i> has a lower <i>f</i> -value of 3, it is the next one to be investigated. Now <i>s</i> will again be added to the agenda, this time with <i>f</i> -value 2+1=3! In fact, it is this latter <i>s</i> which, being on the optimal path, leads to the goal.
 </p>
 <p class="sektie">
  Thus, although admissible search leads to optimal solutions, it is not necessarily the case that every node on an optimal path is immediately reached along that optimal path. In fig. 6.3, this is caused by &lsquo;local pessimism&rsquo; of the heuristic, which estimates the cost of moving from <i>start</i> to <i>p</i> as 3&ndash;1=2, while the actual cost is 1. Indeed, if <i>p</i> would have an <i>h</i> -value of 2, <i>s</i> would have been reached the first time along the shortest path. This is true in general: if the heuristic estimates the cost of moving from one node to another optimistically, then any node is reached along the cheapest path first. This property is called <i>monotonicity</i>, since one can show that the <i>f</i> -values are monotonically non-decreasing along a path.
 </p>
 <div class="extract figure" id="6.3">
  <table align="center" cellpadding="0" cellspacing="0" hspace="0" vspace="0">
   <tr>
    <td align="left" class="AutoStyle04" valign="top">
     <div class="AutoStyle20">
      <p class="med-figure AutoStyle07">
       <img src="img/part_ii/image020.svg" v:shapes="Picture_x0020_11" width="100%">
       </img>
      </p>
     </div>
     <p class="med-caption">
      <b>Figure   6.3</b>. A heuristic which is not monotonic.
     </p>
    </td>
   </tr>
  </table>
 </div>
 <p class="sektie">
  The first heuristic of the previous section is monotonic, while the second is not. This can be concluded from the following two evaluations:
 </p>
 <p class="p-el">
  [b,b,e,w,w,b,w]-9<br>
  [e,b,b,w,w,b,w]-7
</p>
 <p class="tekst">
  The heuristic estimates the cost of this move as 9&ndash;7=2, while the actual cost is 1. Since monotonicity implies admissibility, the third heuristic is not monotonic either.
 </p>
<div class="extract exercise" id="6.5">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 6.5.</i> Implement a Prolog meta-interpreter which employs an A search algorithm. Use <i>h</i> (<i>R</i>)= | <i>R</i> | (the number of literals in resolvent <i>R</i>) as heuristic. Is this heuristic admissible and monotonic?
  </p>
 </div>
</div>
 <h3 id="non_exhaustive_informed_search">
  6.3&nbsp;&nbsp;&nbsp;Non-exhaustive informed search
 </h3>
 <p class="sektie1">
  The search strategies discussed until now are all <i>exhaustive</i>: they will all search the complete search space in the worst case. This is so because <b>all</b> children of a certain node will be put on the agenda, in some order. Exhaustive search&nbsp;is often impractical, since the size of the agenda grows exponentially with the search depth. The use of a heuristic offers the possibility of keeping only a selection of best nodes on the agenda. Such non-exhaustive search strategies are, of course, not guaranteed to be complete, and should only be applied in combination with a reasonably informed heuristic.
 </p>
 <p class="sektie">
  <i>Beam search</i>&nbsp;is a form of best-first search in which the number of nodes on the agenda is limited. In its most simple form, the agenda is of fixed size. Alternatively, one could allow the agenda to grow polynomially (instead of exponentially) with the search depth. The effect of this strategy is, that only a &lsquo;beam&rsquo; of the search space is searched:
 </p>
 <p class="pi-el">
  search_beam(Agenda,Goal):-<br>
  search_beam(1,Agenda,[],Goal).
</p>
 <p class="pi">
  search_beam(D,[],NextLayer,Goal):-<br>
  D1 is D+1,<br>
  search_beam(D1,NextLayer,[],Goal).
</p>
 <p class="pi">
  search_beam(D,[Goal|Rest],NextLayer,Goal):-<br>
  goal(Goal).
</p>
 <p class="pi-laatst">
  search_beam(D,[Current|Rest],NextLayer,Goal):-<br>
  children(Current,Children),<br>
  add_beam(D,Children,NextLayer,NewNextLayer),<br>
  search_beam(D,Rest,NewNextLayer,Goal).
</p>
 <p class="tekst">
  In this program, two agendas are maintained, one for the current level, and one for the children of the nodes on the current level. Once the current level is exhausted, the agenda&rsquo;s are swapped and the depth count is increased. The depth count is passed on to the predicate <tt>add_beam/4</tt>, in order to decide how many children to add to the agenda for the next level.
 </p>
<div class="extract exercise" id="6.6">
 <div class="AutoStyle06">
  <p class="exercise AutoStyle07">
   <i>Exercise 6.6.</i> Extend the program of exercise 6.3 with beam search with fixed agenda size. Demonstrate the non-optimality of the search strategy.
  </p>
 </div>
</div>
 <p class="sektie">
  If we limit the size of the agenda to 1, we arrive at a search strategy called <i>hill-climbing</i>. It is also callled <i>greedy</i> search, since there is no backtrackinginvolved. Hill-climbing is the type of search employed by a wanderer who wants to reach the top of a hill by always moving in the steepest direction. Clearly, she will reach the top of a hill (and never get off it), but it is not necessarily the highest one.
 </p>
 <p class="sektie">
  The predicate <tt>search_hc/2</tt> below implements a hill-climbing search strategy. Instead of maintaining an agenda of nodes yet to be investigated, it maintains a single node in its first argument. Therefore, hill-climbing has some similarity with depth-first search with implicit agenda:
 </p>
 <p class="pi-eerst">
  search_hc(Goal,Goal):-<br>
  goal(Goal).
</p>
 <p class="pi-laatst">
  search_hc(Current,Goal):-<br>
  children(Current,Children),<br>
  select_best(Children,Best),<br>
  search_hc(Best,Goal).
</p>
 <p class="tekst">
  The predicate <tt>select_best/2</tt> selects the best child of the current node, according to the heuristic value to be optimised. To stress that backtracking is not needed after the best child has been selected, one can place a cut before the recursive call in the second clause.
 </p>
 <h3 id="further_reading_6">
  Further reading
 </h3>
 <p class="sektie1">
  Nilsson (1980) gives a gentle introduction to the use of heuristics and their properties. (Pearl, 1984) is the main source for mathematical results on heuristics. The sliding tiles puzzle&nbsp;was taken from (Luger &amp; Stubblefield, 1993).
 </p>
 <p class="referenties">
  <span class="AutoStyle41">
   G.F. Luger &amp; W.A. Stubblefield (
  </span>
  1993)
  <span class="AutoStyle41">
   ,
  </span>
  <i>Artificial Intelligence: Structures and Strategies for Complex Problem Solving</i>, Benjamin/Cummings, second edition.
 </p>
 <p class="referenties">
  <span class="AutoStyle41">
   N.J. Nilsson (
  </span>
  1980)
  <span class="AutoStyle41">
   ,
  </span>
  <i>Principles of Artificial Intelligence</i>, Tioga Press.
 </p>
 <p class="referenties">
  <span class="AutoStyle41">
   J. Pearl
  </span>
  (1984), <i>Heuristics: Intelligent Search Strategies for Computer Problem Solving</i>, Addison-Wesley.
 </p>
</div>
<div>
 <br clear="all">
  <hr align="left" size="1" width="33%">
   <div id="ftn1">
    <p class="MsoFootnoteText">
     <a href="#_ftnref1" name="_ftn1" title="">
      <span class="MsoFootnoteReference">
       <span class="AutoStyle13">
        <span class="AutoStyle14">
         [12]
        </span>
       </span>
      </span>
     </a>
     The remaining disk on A can safely be ignored, since it is the largest.
    </p>
   </div>
   <div id="ftn2">
    <p class="MsoFootnoteText">
     <a href="#_ftnref2" name="_ftn2" title="">
      <span class="MsoFootnoteReference">
       <span class="AutoStyle13">
        <span class="AutoStyle14">
         [13]
        </span>
       </span>
      </span>
     </a>
     Such a program should perform breadth-first search; see Exercise 5.2.
    </p>
   </div>
   <div id="ftn3">
    <p class="MsoFootnoteText">
     <a href="#_ftnref3" name="_ftn3" title="">
      <span class="MsoFootnoteReference">
       <span class="AutoStyle13">
        <span class="AutoStyle14">
         [14]
        </span>
       </span>
      </span>
     </a>
     From now on, we denote a <tt>Predicate</tt> with <tt>Arity</tt> as <tt>Predicate/Arity</tt>. This is because predicates with different arity are different predicates, even if they share the same predicate name.
    </p>
   </div>
   <div id="ftn4">
    <p class="MsoFootnoteText">
     <a href="#_ftnref4" name="_ftn4" title="">
      <span class="MsoFootnoteReference">
       <span class="AutoStyle13">
        <span class="AutoStyle14">
         [15]
        </span>
       </span>
      </span>
     </a>
     Here, we refer to the resultant path, ignoring backtracking.
    </p>
   </div>
   <div id="ftn5">
    <p class="MsoFootnoteText">
     <a href="#_ftnref5" name="_ftn5" title="">
      <span class="MsoFootnoteReference">
       <span class="AutoStyle13">
        <span class="AutoStyle14">
         [16]
        </span>
       </span>
      </span>
     </a>
     We will assume for the moment that the head literals are ground by the substitution which makes the body true; a more detailed discussion follows below.
    </p>
   </div>
   <div id="ftn6">
    <p class="MsoFootnoteText">
     <a href="#_ftnref6" name="_ftn6" title="">
      <span class="MsoFootnoteReference">
       <span class="AutoStyle13">
        <span class="AutoStyle14">
         [17]
        </span>
       </span>
      </span>
     </a>
     If arcs can have different costs, breadth-first search does not necessarily return the <b>cheapest</b> solution path.
    </p>
   </div>
  </hr>
</div>
<script>
 $(function() { $(".swish").LPN({swish:"{{ site.swish }}"}); });
</script>
